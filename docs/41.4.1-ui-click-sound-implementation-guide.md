# UI Click Sound Implementation Guide

## Overview

This document provides comprehensive guidance on implementing consistent UI click sounds across the React application using the `useUIClickSound` hook. This solution provides a clean, reusable approach to audio feedback for user interactions.

## Architecture

### Core Hook: `useUIClickSound`

**Location**: `/src/hooks/useUIClickSound.ts`

The hook provides a standardized way to play UI click sounds with consistent configuration:

```typescript
import useSound from 'use-sound'

export function useUIClickSound() {
  const [playClick] = useSound('/sounds/move.mp3', {
    volume: 0.3, // Consistent volume for all UI interactions
  })
  
  const playUIClick = (context?: string) => {
    try {
      playClick()
      console.log(`ðŸ”Š [UI CLICK] ${context || 'Button'} click sound played`)
    } catch (error) {
      console.warn(`ðŸ”Š [UI CLICK] Failed to play click sound:`, error)
    }
  }
  
  return { playUIClick }
}
```

### Key Features

- **Consistent Sound**: Uses `/sounds/move.mp3` at 30% volume across all components
- **Error Handling**: Built-in try/catch with logging
- **Context Logging**: Optional parameter for debugging specific interactions
- **Single Responsibility**: Only handles UI click sounds

## Implementation Examples

### Basic Button Implementation

```typescript
import React from 'react'
import { useUIClickSound } from '../hooks/useUIClickSound'

function MyButton() {
  const { playUIClick } = useUIClickSound()
  
  const handleClick = () => {
    playUIClick('My Button') // Optional context for logging
    // Your button logic here
  }
  
  return (
    <button onClick={handleClick}>
      Click Me
    </button>
  )
}
```

### Modal with Multiple Actions

```typescript
import React from 'react'
import { X, Check } from 'lucide-react'
import { useUIClickSound } from '../hooks/useUIClickSound'

interface ConfirmModalProps {
  isOpen: boolean
  onConfirm: () => void
  onCancel: () => void
}

function ConfirmModal({ isOpen, onConfirm, onCancel }: ConfirmModalProps) {
  const { playUIClick } = useUIClickSound()
  
  const handleConfirm = () => {
    playUIClick('Modal Confirm')
    onConfirm()
  }
  
  const handleCancel = () => {
    playUIClick('Modal Cancel')
    onCancel()
  }
  
  if (!isOpen) return null
  
  return (
    <div className="modal">
      <button onClick={handleCancel} className="close-btn">
        <X />
      </button>
      <div className="modal-actions">
        <button onClick={handleCancel}>Cancel</button>
        <button onClick={handleConfirm}>
          <Check /> Confirm
        </button>
      </div>
    </div>
  )
}
```

### Navigation Component

```typescript
import React from 'react'
import { useUIClickSound } from '../hooks/useUIClickSound'

interface TabBarProps {
  tabs: Array<{ id: string; label: string }>
  activeTab: string
  onTabChange: (tabId: string) => void
}

function TabBar({ tabs, activeTab, onTabChange }: TabBarProps) {
  const { playUIClick } = useUIClickSound()
  
  const handleTabClick = (tabId: string, tabLabel: string) => {
    playUIClick(`Tab: ${tabLabel}`)
    onTabChange(tabId)
  }
  
  return (
    <div className="tab-bar">
      {tabs.map(tab => (
        <button
          key={tab.id}
          onClick={() => handleTabClick(tab.id, tab.label)}
          className={activeTab === tab.id ? 'active' : ''}
        >
          {tab.label}
        </button>
      ))}
    </div>
  )
}
```

## Implementation Patterns

### 1. Simple Button Pattern

**When to use**: Single action buttons

```typescript
function SimpleButton() {
  const { playUIClick } = useUIClickSound()
  
  return (
    <button onClick={() => {
      playUIClick('Action Name')
      // Action logic
    }}>
      Action
    </button>
  )
}
```

### 2. Handler Function Pattern  

**When to use**: Complex logic or multiple actions

```typescript
function ComplexButton() {
  const { playUIClick } = useUIClickSound()
  
  const handleClick = () => {
    playUIClick('Complex Action')
    // Complex logic here
    validateForm()
    updateState()
    triggerAnimation()
  }
  
  return <button onClick={handleClick}>Submit</button>
}
```

### 3. Conditional Sound Pattern

**When to use**: Actions that should only play sound under certain conditions

```typescript
function ConditionalButton({ isEnabled }: { isEnabled: boolean }) {
  const { playUIClick } = useUIClickSound()
  
  const handleClick = () => {
    if (isEnabled) {
      playUIClick('Enabled Action')
      performAction()
    } else {
      // No sound for disabled state
      showDisabledMessage()
    }
  }
  
  return (
    <button 
      onClick={handleClick}
      disabled={!isEnabled}
    >
      Action
    </button>
  )
}
```

### 4. Form Control Pattern

**When to use**: Form inputs and controls

```typescript
function FormControls() {
  const { playUIClick } = useUIClickSound()
  
  return (
    <div>
      <button 
        type="button"
        onClick={() => {
          playUIClick('Add Item')
          addNewItem()
        }}
      >
        Add Item
      </button>
      
      <button 
        type="submit"
        onClick={() => {
          playUIClick('Form Submit')
          // Form validation happens here
        }}
      >
        Submit
      </button>
      
      <button 
        type="button"
        onClick={() => {
          playUIClick('Form Reset')
          resetForm()
        }}
      >
        Reset
      </button>
    </div>
  )
}
```

## Implemented Components

The following components already have click sounds implemented:

### Navigation Components
- **TabBar**: Tab switching with context like `Tab: Layout`
- **MenuButton**: Hamburger menu toggle
- **MenuDropdown**: All menu items (`Menu: Settings`, `Menu: Help`, etc.)

### Settings & Configuration  
- **ThemeSwitcher**: Settings button click
- **SettingsPanel**: Theme toggle and close button

### Interactive Elements
- **InstructionsFAB**: Help button floating action
- **SlotMachine**: Wager controls and spin button
- **PromotionModal**: Piece selection and cancel actions
- **CheckmateModal**: Play again button

## Best Practices

### 1. Consistent Context Naming

Use descriptive, consistent naming for context logging:

```typescript
// âœ… Good - Clear and descriptive
playUIClick('Settings Close')
playUIClick('Tab: Home')
playUIClick('Modal Confirm')

// âŒ Bad - Vague or inconsistent  
playUIClick('click')
playUIClick('btn')
playUIClick('action1')
```

### 2. Sound Placement

Always call `playUIClick()` **before** the main action:

```typescript
// âœ… Good - Sound plays immediately on click
const handleClick = () => {
  playUIClick('Save Document')
  saveDocument()
  showSuccessMessage()
}

// âŒ Bad - Delayed sound after processing
const handleClick = () => {
  saveDocument()
  showSuccessMessage()  
  playUIClick('Save Document') // Too late!
}
```

### 3. Error Handling

The hook includes built-in error handling, but you can add additional context:

```typescript
const handleCriticalAction = () => {
  try {
    playUIClick('Critical Action')
    performCriticalOperation()
  } catch (error) {
    // Hook already logs audio errors
    // Handle your business logic errors here
    console.error('Critical operation failed:', error)
    showErrorMessage()
  }
}
```

### 4. Accessibility Considerations

Don't rely solely on audio feedback. Always include visual feedback:

```typescript
function AccessibleButton() {
  const { playUIClick } = useUIClickSound()
  const [isLoading, setIsLoading] = useState(false)
  
  const handleClick = async () => {
    playUIClick('Submit Form')
    setIsLoading(true) // Visual feedback
    
    try {
      await submitForm()
      // Success visual feedback
    } catch (error) {
      // Error visual feedback  
    } finally {
      setIsLoading(false)
    }
  }
  
  return (
    <button 
      onClick={handleClick}
      disabled={isLoading}
      aria-label={isLoading ? 'Submitting...' : 'Submit form'}
    >
      {isLoading ? 'Submitting...' : 'Submit'}
    </button>
  )
}
```

## Testing

### Manual Testing Checklist

- [ ] Sound plays immediately on button click
- [ ] Volume is consistent across all buttons (30%)
- [ ] No sound plays on disabled buttons
- [ ] Context logging appears in console
- [ ] No errors in console for successful clicks
- [ ] Graceful fallback if sound file fails to load

### Example Test Code

```typescript
import { render, fireEvent, screen } from '@testing-library/react'
import { MyComponent } from './MyComponent'

// Mock the hook
jest.mock('../hooks/useUIClickSound', () => ({
  useUIClickSound: () => ({
    playUIClick: jest.fn()
  })
}))

test('plays click sound when button is clicked', () => {
  const { playUIClick } = require('../hooks/useUIClickSound').useUIClickSound()
  
  render(<MyComponent />)
  const button = screen.getByRole('button')
  
  fireEvent.click(button)
  
  expect(playUIClick).toHaveBeenCalledWith('Expected Context')
})
```

## Performance Considerations

### Memory Usage
- The hook creates one `useSound` instance per component
- Sound files are cached by the browser after first load
- No memory leaks as hooks clean up automatically

### Network Usage  
- Sound file (`/sounds/move.mp3`) is loaded once and cached
- Total size impact: ~50KB for the sound file
- No additional network requests after initial load

### CPU Usage
- Minimal CPU impact for playing sounds
- Audio processing handled by browser's audio engine
- Error handling prevents crashes from audio failures

## Troubleshooting

### Common Issues

**Sound not playing:**
1. Check browser's autoplay policy
2. Verify sound file exists at `/public/sounds/move.mp3`
3. Check browser console for error messages
4. Ensure user has interacted with page (required for autoplay)

**Inconsistent volume:**  
1. Verify all components use `useUIClickSound` hook
2. Check for hardcoded volume settings in individual components
3. Ensure sound file has consistent baseline volume

**Performance issues:**
1. Check if multiple instances of hook are being created unnecessarily
2. Verify components are properly unmounting to clean up hooks
3. Monitor browser's audio context usage in dev tools

### Debug Logging

Enable detailed audio logging by checking browser console:

```
ðŸ”Š [UI CLICK] Tab: Layout click sound played
ðŸ”Š [UI CLICK] Settings Close click sound played  
ðŸ”Š [UI CLICK] Modal Confirm click sound played
```

Warning messages indicate potential issues:
```
ðŸ”Š [UI CLICK] Failed to play click sound: Error message here
```

## Future Enhancements

### Potential Improvements

1. **Sound Themes**: Different sound sets for different app themes
2. **Volume Control**: User setting to adjust UI sound volume
3. **Sound Packs**: Multiple sound options (beep, click, pop)
4. **Accessibility**: Respect user's reduced motion/sound preferences
5. **Context-Aware Sounds**: Different sounds for different action types

### Migration Path

To add new sounds or modify existing behavior:

1. Extend the hook with additional sound options
2. Add new sound files to `/public/sounds/`
3. Update context naming conventions in this document
4. Test across all existing components

## Conclusion

The `useUIClickSound` hook provides a robust, consistent solution for UI audio feedback. By following the patterns and best practices outlined in this document, you can ensure a polished, professional user experience with appropriate audio cues for all user interactions.

For questions or issues, refer to the troubleshooting section or check the implementation examples in existing components like `TabBar`, `MenuButton`, and `SettingsPanel`.