# Craps Game Implementation Plan

## Game Overview

This document provides a complete standalone implementation plan for the Craps game, featuring simplified craps rules optimized for mobile play, realistic dice physics simulation, clear game phase transitions, mobile-optimized betting interface, and seamless integration with the existing casino infrastructure.

### Simplified Craps Rules for Mobile Play

The implementation focuses on core craps betting to reduce complexity while maintaining the excitement of the game:

- **Core Bets Only**: Pass line, don't pass, field, and basic proposition bets
- **Two-Phase Game**: Come out roll (establish point) and point phase (resolve point)  
- **Mobile-Friendly**: Reduced complexity focusing on most popular bets
- **Clear Instructions**: Visual guides for new players learning craps rules

### Game Flow
1. **Come Out Roll Phase**: Players place pass/don't pass bets
2. **Dice Roll**: Physics-based dice simulation with authentic rolling
3. **Outcome Resolution**: 7/11 wins pass line, 2/3/12 loses, 4/5/6/8/9/10 establishes point
4. **Point Phase**: Roll again to either make the point or seven out
5. **Payout Processing**: Calculate and distribute winnings based on bet types

## Technical Requirements

### Core Dependencies
- React 18+ with TypeScript for component development
- Zustand for state management integration with existing casino store
- React Spring for smooth dice rolling animations and physics
- Web Audio API integration for authentic dice rolling sounds
- Crypto API for cryptographically secure random number generation

### Performance Requirements
- **60fps Animations**: Smooth dice rolling with hardware acceleration
- **<16ms Render Times**: Optimized React component updates
- **2-3 Second Roll Duration**: Realistic timing with multiple bounces
- **Touch Response**: <50ms response to betting interactions
- **Battery Optimization**: Efficient audio and animation management

### Browser Support
- Modern mobile browsers with Web Audio API support
- Crypto API availability for secure random generation
- CSS transforms and transitions for smooth animations
- Touch event handling for mobile betting interface

## Files to Create

### Domain Layer (Business Logic)

#### Core Services
- `src/services/casino/craps/CrapsGameService.ts` - Core game rules and betting logic
- `src/services/casino/craps/DicePhysicsService.ts` - Dice rolling physics and animation
- `src/services/casino/craps/BettingTableService.ts` - Bet validation and payout calculation
- `src/services/casino/craps/GamePhaseService.ts` - Come out vs point phase management
- `src/services/casino/craps/PayoutCalculatorService.ts` - Complex payout rules for all bet types

### Type Definitions and Value Objects

#### Types
- `src/types/casino/craps.types.ts` - All craps domain types and betting options

#### Utilities
- `src/utils/casino/craps/dice-combinations.utils.ts` - Dice outcome analysis and probabilities
- `src/utils/casino/craps/bet-validation.utils.ts` - Betting rules and restrictions  
- `src/utils/casino/craps/payout-calculation.utils.ts` - True odds and house edge calculations
- `src/utils/casino/craps/game-phase.utils.ts` - Phase transition logic and rules

### Constants and Configuration

#### Constants
- `src/constants/casino/craps/bet-types.constants.ts` - All craps bets with odds and payouts
- `src/constants/casino/craps/dice-combinations.constants.ts` - All possible dice outcomes
- `src/constants/casino/craps/table-limits.constants.ts` - Minimum and maximum bet limits
- `src/constants/casino/craps/true-odds.constants.ts` - Mathematical odds for all bets

### Application Services (Hooks)

#### Custom Hooks
- `src/hooks/casino/useCraps.ts` - Main game state management hook
- `src/hooks/casino/useCrapsBetting.ts` - Betting interface and validation
- `src/hooks/casino/useDiceAnimation.ts` - Dice rolling animation control
- `src/hooks/casino/useCrapsHistory.ts` - Roll history and pattern tracking

### Presentation Layer (Components)

#### Page Component
- `src/pages/casino/CrapsPage.tsx` - Main craps page component

#### Game Components
- `src/components/casino/craps/CrapsTable.tsx` - Complete craps table layout
- `src/components/casino/craps/DiceArea.tsx` - Dice display with physics animation
- `src/components/casino/craps/BettingLayout.tsx` - Simplified betting areas for mobile
- `src/components/casino/craps/PassLineBets.tsx` - Pass/don't pass betting interface
- `src/components/casino/craps/PointDisplay.tsx` - Current point and phase indicator
- `src/components/casino/craps/RollHistory.tsx` - Recent dice rolls and outcomes
- `src/components/casino/craps/PayoutDisplay.tsx` - Winning bet announcements

## Files to Modify

### Integration Files
- `src/pages/index.ts` (add CrapsPage export)
- `src/App.tsx` (add craps routing)
- `src/types/casino/index.ts` (add craps types export)
- `src/stores/casinoStore.ts` (add craps game state)

## Integration Points with Main Infrastructure

### Existing Services (Used But Not Modified)
- `src/services/casino/CasinoRNGService.ts` - Dice rolling random generation
- `src/stores/casinoStore.ts` - Balance management and betting history
- `src/hooks/casino/useCasinoAudio.ts` - Dice rolling and winning sounds
- `src/components/casino/shared/TouchFeedback.tsx` - Betting area interactions

### Shared Components Integration
The craps game will leverage existing shared casino components:
- **BetControls**: Chip selection and betting amount inputs
- **CoinDisplay**: Balance and winnings display
- **TouchFeedback**: Visual feedback for betting interactions
- **AudioControls**: Sound effects and volume management

## Detailed Implementation Steps

### Phase 1: Domain Model Foundation (Priority: High)

#### Step 1.1: Core Type Definitions
Create `src/types/casino/craps.types.ts` with comprehensive type system:

```typescript
// Core game state types
export interface CrapsGameState {
  currentPhase: 'come-out' | 'point'
  point: number | null
  placedBets: CrapsBet[]
  totalBetAmount: number
  isRolling: boolean
  rollHistory: CrapsRollHistory[]
  sessionStats: CrapsSessionStats
}

// Bet types and validation
export interface CrapsBet {
  id: string
  type: CrapsBetType
  amount: number
  phase: 'come-out' | 'point'
  point: number | null
  placedAt: number
  odds: PayoutOdds
}

export type CrapsBetType = 
  | 'pass-line' 
  | 'dont-pass' 
  | 'field' 
  | 'any-craps' 
  | 'any-seven'

// Dice and physics types
export interface DiceRoll {
  die1: number
  die2: number
  timestamp: number
  physics: DicePhysicsState
}

export interface DicePhysicsState {
  velocity: number
  bounces: number
  duration: number
  finalPosition: { x: number, y: number }
}
```

#### Step 1.2: Constants Configuration
Implement betting odds and game constants:

```typescript
// src/constants/casino/craps/bet-types.constants.ts
export const CRAPS_BET_PAYOUTS = {
  'pass-line': { payout: 1, trueOdds: 1.41, description: 'Pass Line' },
  'dont-pass': { payout: 1, trueOdds: 1.36, description: "Don't Pass" },
  'field': { payout: 1, trueOdds: 2.78, description: 'Field Bet' },
  'any-craps': { payout: 7, trueOdds: 11.11, description: 'Any Craps' },
  'any-seven': { payout: 4, trueOdds: 16.67, description: 'Any Seven' }
} as const

export const DICE_COMBINATIONS = {
  2: ['1-1'],
  3: ['1-2', '2-1'], 
  4: ['1-3', '2-2', '3-1'],
  5: ['1-4', '2-3', '3-2', '4-1'],
  6: ['1-5', '2-4', '3-3', '4-2', '5-1'],
  7: ['1-6', '2-5', '3-4', '4-3', '5-2', '6-1'],
  8: ['2-6', '3-5', '4-4', '5-3', '6-2'],
  9: ['3-6', '4-5', '5-4', '6-3'],
  10: ['4-6', '5-5', '6-4'],
  11: ['5-6', '6-5'],
  12: ['6-6']
} as const
```

### Phase 2: Domain Services Implementation (Priority: High)

#### Step 2.1: Core Game Service
Implement `src/services/casino/craps/CrapsGameService.ts`:

```typescript
export class CrapsGameService {
  private readonly dicePhysics: DicePhysicsService
  private readonly bettingTable: BettingTableService
  private readonly gamePhase: GamePhaseService
  private readonly payoutCalculator: PayoutCalculatorService

  constructor(
    dicePhysics: DicePhysicsService,
    bettingTable: BettingTableService,
    gamePhase: GamePhaseService,
    payoutCalculator: PayoutCalculatorService
  ) {
    this.dicePhysics = dicePhysics
    this.bettingTable = bettingTable
    this.gamePhase = gamePhase
    this.payoutCalculator = payoutCalculator
  }

  // Core domain operation - roll dice and resolve all bets
  public async rollDice(gameState: CrapsGameState): Promise<CrapsRollResult> {
    if (gameState.placedBets.length === 0) {
      throw new CrapsGameError('No bets placed')
    }

    // Execute dice roll with physics simulation
    const rollResult = await this.dicePhysics.rollDice()
    const totalValue = rollResult.die1 + rollResult.die2
    
    // Determine game outcome based on current phase
    const outcome = this.determineOutcome(gameState, totalValue, rollResult)
    
    // Process all bet resolutions
    const betResults = this.payoutCalculator.resolveBets(
      gameState.placedBets,
      outcome,
      gameState.currentPhase,
      gameState.point
    )

    return {
      success: true,
      diceRoll: rollResult,
      totalValue,
      outcome,
      betResults,
      totalWinnings: betResults.reduce((sum, result) => 
        result.isWin ? sum + result.payout : sum, 0
      ),
      nextGameState: this.buildNextGameState(gameState, outcome, betResults)
    }
  }

  private determineOutcome(
    gameState: CrapsGameState,
    totalValue: number,
    diceRoll: DiceRoll
  ): CrapsOutcome {
    if (gameState.currentPhase === 'come-out') {
      if (totalValue === 7 || totalValue === 11) {
        return { type: 'natural-win', description: 'Natural winner!' }
      }
      if (totalValue === 2 || totalValue === 3 || totalValue === 12) {
        return { type: 'craps', description: 'Craps!' }
      }
      return { 
        type: 'point-established', 
        description: `Point is ${totalValue}`,
        pointValue: totalValue
      }
    } else {
      if (totalValue === gameState.point) {
        return { type: 'point-made', description: `${totalValue} winner!` }
      }
      if (totalValue === 7) {
        return { type: 'seven-out', description: 'Seven out!' }
      }
      return { type: 'no-decision', description: 'Roll again' }
    }
  }
}
```

#### Step 2.2: Dice Physics Service
Create realistic dice physics in `src/services/casino/craps/DicePhysicsService.ts`:

```typescript
export class DicePhysicsService {
  private readonly rngService: CasinoRNGService

  constructor(rngService: CasinoRNGService) {
    this.rngService = rngService
  }

  public async rollDice(): Promise<DiceRoll> {
    // Generate cryptographically secure random values
    const die1 = Math.floor(this.rngService.randomFloat() * 6) + 1
    const die2 = Math.floor(this.rngService.randomFloat() * 6) + 1

    // Simulate physics properties for animation
    const physics = this.simulatePhysics()

    return {
      die1,
      die2,
      timestamp: Date.now(),
      physics
    }
  }

  private simulatePhysics(): DicePhysicsState {
    return {
      velocity: 800 + (this.rngService.randomFloat() * 400), // 800-1200 px/s
      bounces: 2 + Math.floor(this.rngService.randomFloat() * 3), // 2-4 bounces
      duration: 2500 + (this.rngService.randomFloat() * 1000), // 2.5-3.5 seconds
      finalPosition: {
        x: 50 + (this.rngService.randomFloat() * 200), // Random final position
        y: 50 + (this.rngService.randomFloat() * 100)
      }
    }
  }
}
```

### Phase 3: Game State Management (Priority: High)

#### Step 3.1: Main Game Hook
Implement `src/hooks/casino/useCraps.ts`:

```typescript
export const useCraps = (): CrapsGameHook => {
  const { balance, placeBet, addWinnings } = useCasinoBalance()
  const { playSound } = useCasinoAudio()
  const { vibrate } = useHapticFeedback()
  
  const gameServiceRef = useRef(new CrapsGameService(
    new DicePhysicsService(new CasinoRNGService()),
    new BettingTableService(),
    new GamePhaseService(),
    new PayoutCalculatorService()
  ))

  const [gameState, setGameState] = useState<CrapsGameState>({
    currentPhase: 'come-out',
    point: null,
    placedBets: [],
    totalBetAmount: 0,
    isRolling: false,
    rollHistory: [],
    sessionStats: { rolls: 0, totalWagered: 0, totalWon: 0 }
  })

  const [diceAnimation, setDiceAnimation] = useState<DiceAnimationState>({
    isRolling: false,
    die1Value: 1,
    die2Value: 1,
    rollDuration: 0
  })

  const rollDice = useCallback(async (): Promise<boolean> => {
    if (gameState.placedBets.length === 0) {
      toast.error('Place at least one bet before rolling')
      return false
    }

    setGameState(prev => ({ ...prev, isRolling: true }))
    setDiceAnimation(prev => ({ ...prev, isRolling: true }))
    
    try {
      playSound('diceRoll')
      vibrate('spin')

      const rollResult = await gameServiceRef.current.rollDice(gameState)
      
      if (rollResult.success) {
        // Animate dice with physics timing
        const rollDuration = rollResult.diceRoll.physics.duration
        setDiceAnimation({
          isRolling: true,
          die1Value: rollResult.diceRoll.die1,
          die2Value: rollResult.diceRoll.die2,
          rollDuration
        })

        // Wait for animation completion
        await new Promise(resolve => setTimeout(resolve, rollDuration))
        
        setGameState(rollResult.nextGameState)
        setDiceAnimation(prev => ({ ...prev, isRolling: false }))

        // Handle outcome audio
        this.playOutcomeAudio(rollResult.outcome)

        if (rollResult.totalWinnings > 0) {
          addWinnings(rollResult.totalWinnings)
        }

        return true
      }
    } catch (error) {
      toast.error('Roll failed: ' + error.message)
      this.resetRollingState()
      return false
    }
  }, [gameState, playSound, vibrate, addWinnings])

  return {
    gameState,
    diceAnimation,
    actions: {
      placeBet: placeBetOnTable,
      rollDice
    },
    computed: {
      canRoll: gameState.placedBets.length > 0 && !gameState.isRolling,
      phase: gameState.currentPhase,
      point: gameState.point,
      availableBets: getAvailableBets(gameState.currentPhase)
    }
  }
}
```

### Phase 4: User Interface Components (Priority: Medium)

#### Step 4.1: Main Game Page
Create `src/pages/casino/CrapsPage.tsx`:

```typescript
export const CrapsPage: React.FC = () => {
  const {
    gameState,
    diceAnimation,
    actions,
    computed
  } = useCraps()

  return (
    <div className="craps-page">
      <div className="game-header">
        <PointDisplay 
          phase={computed.phase}
          point={computed.point}
        />
        <CoinDisplay />
      </div>

      <div className="dice-area">
        <DiceArea 
          diceAnimation={diceAnimation}
          onRoll={actions.rollDice}
          disabled={!computed.canRoll}
        />
      </div>

      <div className="betting-section">
        <BettingLayout
          availableBets={computed.availableBets}
          onPlaceBet={actions.placeBet}
          placedBets={gameState.placedBets}
        />
      </div>

      <div className="game-info">
        <RollHistory rolls={gameState.rollHistory} />
        <PayoutDisplay 
          lastOutcome={gameState.lastOutcome}
          winnings={gameState.lastWinnings}
        />
      </div>
    </div>
  )
}
```

#### Step 4.2: Dice Animation Component
Implement `src/components/casino/craps/DiceArea.tsx`:

```typescript
export const DiceArea: React.FC<DiceAreaProps> = ({
  diceAnimation,
  onRoll,
  disabled
}) => {
  const diceSpring = useSpring({
    transform: diceAnimation.isRolling 
      ? `rotateX(${Math.random() * 720}deg) rotateY(${Math.random() * 720}deg)`
      : 'rotateX(0deg) rotateY(0deg)',
    config: {
      duration: diceAnimation.rollDuration,
      easing: easings.easeOutCubic
    }
  })

  return (
    <div className="dice-area">
      <animated.div 
        className="dice-container"
        style={diceSpring}
      >
        <Die value={diceAnimation.die1Value} />
        <Die value={diceAnimation.die2Value} />
      </animated.div>
      
      <button
        className="roll-button"
        onClick={onRoll}
        disabled={disabled || diceAnimation.isRolling}
      >
        {diceAnimation.isRolling ? 'Rolling...' : 'Roll Dice'}
      </button>
    </div>
  )
}
```

### Phase 5: Mobile-First Design (Priority: Medium)

#### Step 5.1: Touch-Optimized Betting Interface
Create responsive betting areas in `src/components/casino/craps/BettingLayout.tsx`:

```typescript
export const BettingLayout: React.FC<BettingLayoutProps> = ({
  availableBets,
  onPlaceBet,
  placedBets
}) => {
  return (
    <div className="betting-layout">
      <div className="primary-bets">
        <BettingArea
          type="pass-line"
          label="PASS LINE"
          payout="1:1"
          onBet={(amount) => onPlaceBet('pass-line', amount)}
          placedAmount={getBetAmount(placedBets, 'pass-line')}
        />
        <BettingArea
          type="dont-pass"
          label="DON'T PASS"
          payout="1:1" 
          onBet={(amount) => onPlaceBet('dont-pass', amount)}
          placedAmount={getBetAmount(placedBets, 'dont-pass')}
        />
      </div>

      <div className="secondary-bets">
        <BettingArea
          type="field"
          label="FIELD"
          payout="1:1"
          onBet={(amount) => onPlaceBet('field', amount)}
          placedAmount={getBetAmount(placedBets, 'field')}
        />
      </div>
    </div>
  )
}
```

#### Step 5.2: Mobile-Optimized Styling
Implement touch-friendly CSS with minimum 44px touch targets:

```css
.betting-area {
  min-height: 44px;
  min-width: 44px;
  padding: 16px;
  margin: 8px;
  border-radius: 12px;
  touch-action: manipulation;
  user-select: none;
  
  /* Visual feedback for touches */
  transition: all 0.15s ease;
}

.betting-area:active {
  transform: scale(0.95);
  background-color: var(--highlight-color);
}

.dice-container {
  display: flex;
  gap: 24px;
  justify-content: center;
  align-items: center;
  padding: 32px;
}

.roll-button {
  min-height: 56px;
  min-width: 120px;
  font-size: 18px;
  font-weight: bold;
  border-radius: 28px;
}
```

### Phase 6: Audio Integration (Priority: Low)

#### Step 6.1: Dice Sound Effects
Extend existing audio service with craps-specific sounds:

```typescript
// Audio files to add to public/sounds/casino/
const CRAPS_SOUNDS = {
  diceShake: 'dice-shake.mp3',     // Pre-roll shaking sound
  diceRoll: 'dice-roll.mp3',       // Rolling/bouncing sound  
  diceSettle: 'dice-settle.mp3',   // Final settling sound
  pointEstablished: 'point.mp3',   // Point establishment chime
  natural: 'natural-win.mp3',      // Natural 7/11 win
  craps: 'craps-lose.mp3',         // Craps 2/3/12 lose
  sevenOut: 'seven-out.mp3'        // Seven out sound
}

// Integration with existing useCasinoAudio hook
const playOutcomeAudio = (outcome: CrapsOutcome) => {
  switch (outcome.type) {
    case 'natural-win':
      playSound('natural')
      break
    case 'craps':
      playSound('craps')
      break
    case 'point-established':
      playSound('pointEstablished')
      break
    case 'seven-out':
      playSound('sevenOut')
      break
    case 'point-made':
      playSound('winSmall')
      break
    default:
      playSound('diceSettle')
  }
}
```

### Phase 7: Testing Requirements (Priority: High)

#### Step 7.1: Unit Tests
Create comprehensive test coverage:

```typescript
// tests/services/CrapsGameService.test.ts
describe('CrapsGameService', () => {
  describe('rollDice', () => {
    it('should establish point on come-out roll of 4,5,6,8,9,10', async () => {
      const gameState = createComeOutGameState()
      const mockRoll = { die1: 2, die2: 2 } // Total 4
      
      const result = await service.rollDice(gameState)
      
      expect(result.outcome.type).toBe('point-established')
      expect(result.nextGameState.point).toBe(4)
      expect(result.nextGameState.currentPhase).toBe('point')
    })

    it('should win pass line on natural 7 or 11', async () => {
      const gameState = createGameStateWithPassBet()
      const mockRoll = { die1: 3, die2: 4 } // Total 7
      
      const result = await service.rollDice(gameState)
      
      expect(result.outcome.type).toBe('natural-win')
      expect(result.totalWinnings).toBeGreaterThan(0)
    })
  })
})

// tests/components/DiceArea.test.tsx  
describe('DiceArea', () => {
  it('should disable roll button when no bets placed', () => {
    render(<DiceArea diceAnimation={mockAnimation} onRoll={mockRoll} disabled={true} />)
    
    expect(screen.getByText('Roll Dice')).toBeDisabled()
  })

  it('should show rolling state during animation', () => {
    const rollingAnimation = { ...mockAnimation, isRolling: true }
    render(<DiceArea diceAnimation={rollingAnimation} onRoll={mockRoll} disabled={false} />)
    
    expect(screen.getByText('Rolling...')).toBeInTheDocument()
  })
})
```

#### Step 7.2: Integration Tests
Test complete game flow:

```typescript
// tests/integration/craps-game-flow.test.tsx
describe('Craps Game Flow', () => {
  it('should complete full come-out to point resolution', async () => {
    render(<CrapsPage />)
    
    // Place pass line bet
    fireEvent.click(screen.getByText('PASS LINE'))
    fireEvent.click(screen.getByText('$10'))
    
    // Roll to establish point  
    fireEvent.click(screen.getByText('Roll Dice'))
    await waitFor(() => expect(screen.getByText(/Point is/)).toBeVisible())
    
    // Roll to make point
    fireEvent.click(screen.getByText('Roll Dice'))  
    await waitFor(() => expect(screen.getByText(/winner!/)).toBeVisible())
    
    expect(screen.getByText(/You won/)).toBeVisible()
  })
})
```

## Dice Physics System

### Animation Framework
- **React Spring Integration**: Smooth 60fps animations with spring physics
- **Transform-based Movement**: Hardware-accelerated CSS transforms
- **Variable Timing**: 2.5-3.5 second rolls with realistic deceleration
- **Multiple Bounces**: 2-4 bounces per roll with velocity dampening

### Visual Design
- **3D Dice Appearance**: CSS transforms for realistic 3D dice
- **Readable Numbers**: High contrast white dots on red dice faces  
- **Rolling Animation**: Continuous rotation during roll sequence
- **Final Position**: Random final positioning within dice area

### Physics Simulation
```typescript
const simulateDicePhysics = () => {
  return {
    initialVelocity: 800 + Math.random() * 400,  // 800-1200 px/s
    deceleration: 0.95, // Velocity multiplier per frame
    bounceCount: 2 + Math.floor(Math.random() * 3), // 2-4 bounces
    rotationSpeed: 720 + Math.random() * 360, // 720-1080 degrees
    duration: 2500 + Math.random() * 1000 // 2.5-3.5 seconds
  }
}
```

## Game Phases System

### Come Out Phase
- **Available Bets**: Pass line, don't pass, field bets, proposition bets  
- **Winning Conditions**: 7 or 11 wins pass line, 2/3/12 loses pass line
- **Point Establishment**: 4,5,6,8,9,10 establishes point and moves to point phase
- **Visual Indicators**: Clear "Come Out Roll" indicator and available betting areas

### Point Phase  
- **Point Display**: Large, prominent display of established point number
- **Winning Conditions**: Roll point number to win pass line, 7 to lose pass line
- **Betting Restrictions**: Some bets not available during point phase
- **Phase Transition**: Win/lose returns to come out phase

### State Management
```typescript
const updateGamePhase = (currentPhase: GamePhase, rollTotal: number, point?: number) => {
  if (currentPhase === 'come-out') {
    if ([7, 11].includes(rollTotal)) return { phase: 'come-out', point: null }
    if ([2, 3, 12].includes(rollTotal)) return { phase: 'come-out', point: null }
    return { phase: 'point', point: rollTotal } // Establish point
  } else {
    if (rollTotal === point) return { phase: 'come-out', point: null } // Point made
    if (rollTotal === 7) return { phase: 'come-out', point: null } // Seven out
    return { phase: 'point', point } // Continue point phase
  }
}
```

## Betting System

### Core Bet Types

#### Pass Line Bet
- **Payout**: 1:1 (even money)
- **House Edge**: 1.41%
- **Rules**: Win on 7/11 come out, lose on 2/3/12, establish point on 4/5/6/8/9/10
- **Point Phase**: Win if point made, lose on seven out

#### Don't Pass Bet  
- **Payout**: 1:1 (even money)
- **House Edge**: 1.36%
- **Rules**: Opposite of pass line, push on 12 in some casinos
- **Point Phase**: Win on seven out, lose if point made

#### Field Bet
- **Payout**: 1:1 on most numbers, 2:1 on 2 and 12
- **House Edge**: 2.78%
- **Rules**: One-roll bet on 2,3,4,9,10,11,12
- **Settlement**: Resolved immediately after each roll

### Bet Validation
```typescript
const validateBet = (
  betType: CrapsBetType,
  amount: number, 
  phase: GamePhase,
  currentBets: CrapsBet[]
): BetValidation => {
  // Check minimum/maximum limits
  if (amount < BET_LIMITS[betType].min) {
    return { isValid: false, error: 'Bet below minimum' }
  }
  
  // Check phase restrictions  
  if (!ALLOWED_BETS[phase].includes(betType)) {
    return { isValid: false, error: 'Bet not allowed in this phase' }
  }

  // Check for conflicting bets
  if (hasConflictingBet(betType, currentBets)) {
    return { isValid: false, error: 'Conflicting bet already placed' }
  }

  return { isValid: true }
}
```

### Payout Calculation
```typescript
const calculatePayout = (bet: CrapsBet, outcome: CrapsOutcome): BetResult => {
  switch (bet.type) {
    case 'pass-line':
      if (outcome.type === 'natural-win' || outcome.type === 'point-made') {
        return { isWin: true, payout: bet.amount * 2 } // Return bet + winnings
      }
      if (outcome.type === 'craps' || outcome.type === 'seven-out') {
        return { isWin: false, payout: 0 }
      }
      return { isWin: false, payout: 0, isResolved: false } // Ongoing bet
      
    case 'field':
      if ([2, 3, 4, 9, 10, 11, 12].includes(outcome.totalValue)) {
        const multiplier = [2, 12].includes(outcome.totalValue) ? 3 : 2 // 2:1 or 1:1
        return { isWin: true, payout: bet.amount * multiplier }
      }
      return { isWin: false, payout: 0 }
  }
}
```

## Mobile-First Design Considerations

### Touch Interface Design
- **Minimum Touch Targets**: 44x44px minimum for all interactive elements
- **Visual Feedback**: Immediate scale/color feedback on touch
- **Gesture Prevention**: `touch-action: manipulation` to prevent zoom
- **Accessibility**: High contrast ratios and screen reader support

### Layout Optimization
```css
.craps-table {
  display: grid;
  grid-template-rows: auto 1fr auto auto;
  grid-template-areas:
    "header"
    "dice"  
    "betting"
    "info";
  height: 100vh;
  padding: 16px;
  gap: 16px;
}

@media (orientation: landscape) {
  .craps-table {
    grid-template-columns: 1fr 2fr;
    grid-template-areas:
      "header header"
      "betting dice"
      "info info";
  }
}
```

### Performance Optimization
- **Hardware Acceleration**: Use `transform` instead of changing position properties
- **Animation Efficiency**: `will-change: transform` on animated elements
- **Touch Responsiveness**: Debounce rapid taps, 16ms maximum response time
- **Battery Optimization**: Pause animations when page not visible

### Responsive Breakpoints
```typescript
const BREAKPOINTS = {
  mobile: '(max-width: 768px)',
  tablet: '(min-width: 769px) and (max-width: 1024px)', 
  desktop: '(min-width: 1025px)'
}

const getBettingLayout = (breakpoint: string) => {
  switch (breakpoint) {
    case 'mobile':
      return 'vertical' // Stack betting areas vertically
    case 'tablet': 
      return 'grid' // 2x2 grid layout
    default:
      return 'traditional' // Full craps table layout
  }
}
```

## Implementation Priority Order

### Phase 1: Foundation (Week 1)
1. Create type definitions and domain models
2. Implement core game service with basic craps rules
3. Set up dice physics service with random generation
4. Create basic game state management hook

### Phase 2: Core Gameplay (Week 2)  
1. Implement betting validation and payout calculation
2. Create game phase management system
3. Build dice animation system with React Spring
4. Develop basic UI components (dice area, betting layout)

### Phase 3: User Interface (Week 3)
1. Create complete craps page component  
2. Implement mobile-optimized betting interface
3. Add point display and game status indicators
4. Build roll history and payout display components

### Phase 4: Integration & Polish (Week 4)
1. Integrate with existing casino infrastructure
2. Add comprehensive audio effects
3. Implement haptic feedback for mobile
4. Create complete test coverage

### Phase 5: Optimization (Week 5)
1. Performance optimization and animation tuning  
2. Accessibility improvements and screen reader support
3. Cross-device testing and bug fixes
4. Documentation and code review

## Success Metrics

### Technical Performance
- **60fps Animations**: Smooth dice rolling and UI transitions
- **<50ms Touch Response**: Immediate feedback on betting interactions  
- **<16ms Render Time**: Optimized React component updates
- **80%+ Test Coverage**: Comprehensive unit and integration tests

### User Experience
- **Intuitive Betting**: Easy-to-understand betting interface for new players
- **Realistic Physics**: Authentic dice rolling with proper timing and bouncing
- **Clear Game State**: Always clear what phase the game is in and what bets are available
- **Mobile Optimization**: Excellent experience on phones and tablets

### Game Integrity
- **Cryptographic RNG**: Provably fair dice generation using Web Crypto API
- **Accurate Payouts**: Mathematically correct odds and payout calculations
- **Proper Rules**: Faithful implementation of simplified craps rules
- **Error Handling**: Graceful handling of edge cases and network issues

This comprehensive implementation plan provides everything needed to build a complete, mobile-optimized craps game that integrates seamlessly with the existing casino infrastructure while delivering an authentic and engaging gaming experience.