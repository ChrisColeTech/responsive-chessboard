# Chess-Themed Slots Game Implementation Plan

## Overview

This document provides a comprehensive standalone implementation plan for the Chess-Themed Slots Game, assuming the main casino infrastructure is already in place. This 3-reel, single-payline slot machine features chess piece symbols (♔♕♖♗♘♙) with mobile-first design, realistic physics animations, and professional casino-grade audio integration.

### Game Concept
- **Theme**: Chess pieces as slot symbols
- **Format**: 3-reel, single-payline (center line)
- **Target**: Mobile-first, touch-optimized gameplay
- **Audio**: Integrated with existing casino sound library
- **Performance**: 60fps animations, sub-16ms response times

## Chess Symbol System

### Symbol Hierarchy & Payouts
The slot machine uses Unicode chess symbols with carefully balanced probabilities and payouts:

| Symbol | Name | Probability | Payout (3x) | Rarity |
|--------|------|-------------|-------------|---------|
| ♔ | King | 5% | 100x | Jackpot |
| ♕ | Queen | 8% | 25x | Big Win |
| ♖ | Rook | 12% | 10x | Good Win |
| ♗ | Bishop | 15% | 8x | Medium Win |
| ♘ | Knight | 15% | 5x | Small Win |
| ♙ | Pawn | 20% | 2x | Base Win |

*Note: Both white and black pieces use same probabilities for visual variety*

### Chess Piece Weights Configuration
```typescript
const CHESS_SYMBOL_WEIGHTS = {
  '♔': 0.05, // King - 5% (rarest)
  '♕': 0.08, // Queen - 8%
  '♖': 0.12, // Rook - 12%
  '♗': 0.15, // Bishop - 15%
  '♘': 0.15, // Knight - 15%
  '♙': 0.20, // Pawn - 20% (most common)
  // Black pieces (♚♛♜♝♞♟) with same weights for visual variety
} as const
```

## Technical Requirements

### Core Technologies
- **Frontend**: React 18+ with TypeScript
- **State Management**: Zustand with persistence
- **Animations**: React Spring for hardware-accelerated physics
- **Audio**: Web Audio API with sound pooling
- **Styling**: Tailwind CSS with CSS Grid
- **RNG**: Cryptographically secure `crypto.getRandomValues()`

### Performance Targets
- **Frame Rate**: Consistent 60fps during animations
- **Response Time**: <16ms touch response
- **Spin Duration**: 2.5s with 200-400ms reel stagger
- **Audio Latency**: <50ms sound trigger
- **Bundle Size**: <200KB additional footprint

### Browser Support
- **Mobile**: iOS 13+, Android 8+
- **Desktop**: Chrome 90+, Safari 14+, Firefox 88+
- **PWA**: Service Worker compatible
- **Accessibility**: WCAG 2.1 AA compliant

## Files to Create/Modify

### New Slot-Specific Files

#### Core Game Logic
```
src/services/casino/slots/
├── SlotGameService.ts          # Main game logic and state management
├── SlotRNGService.ts          # Weighted random generation for symbols
├── WinDetectionService.ts     # Payline evaluation and win calculation
├── NearMissService.ts         # Near-miss effect generation (18% rate)
└── PayoutCalculationService.ts # Payout multipliers and validation
```

#### React Components
```
src/components/casino/slots/
├── SlotsPage.tsx              # Main slots page container
├── EnhancedSlotMachine.tsx    # Complete slot machine component
├── SlotReel.tsx               # Individual animated reel
├── ReelSymbol.tsx             # Chess piece symbol display
├── SpinButton.tsx             # Touch-optimized spin control
├── BetControls.tsx            # Bet amount adjustment controls
├── WinLineIndicator.tsx       # Visual win line highlighting
├── WinCelebration.tsx         # Win animation and effects
└── index.ts                   # Component exports
```

#### Animation System
```
src/animations/casino/slots/
├── reel-spin.animations.ts    # React Spring reel physics
├── win-celebration.animations.ts # Win effects and scaling
├── symbol-highlight.animations.ts # Winning symbol emphasis
└── ui-feedback.animations.ts  # Button press animations
```

#### Game Hooks
```
src/hooks/casino/slots/
├── useSlotMachine.ts          # Main game state hook
├── useSlotAnimations.ts       # Animation control hook
├── useReelPhysics.ts          # Reel spinning mechanics
└── useWinDetection.ts         # Win checking and payout
```

#### Types & Constants
```
src/types/casino/slots/
├── slot-machine.types.ts      # Game state and result types
├── reel.types.ts              # Reel and symbol types
└── animation.types.ts         # Animation state types

src/constants/casino/slots/
├── symbols.constants.ts       # Chess piece definitions
├── payouts.constants.ts       # Payout table configuration
├── physics.constants.ts       # Animation timing constants
└── audio.constants.ts         # Sound effect mappings
```

### Files to Modify
- `src/pages/casino/index.ts` - Add SlotsPage export
- `src/App.tsx` - Add slots routing
- `src/types/casino/index.ts` - Add slots type exports
- `src/stores/casinoStore.ts` - Add slots game state

## Integration Points with Main Infrastructure

### Casino Store Integration
```typescript
// Existing casinoStore.ts integration points
interface CasinoState {
  // Slots will use these existing properties
  coinBalance: number           // Balance management
  currentGame: 'slots' | ...    // Game session tracking
  transactionHistory: Transaction[] // Bet/win logging
  sessionStats: SessionStats   // Statistics tracking
}

interface CasinoActions {
  // Slots will use these existing methods
  placeBet: (amount: number) => boolean
  addWinnings: (amount: number) => void
  startGameSession: (gameType: 'slots') => void
  endGameSession: () => void
}
```

### Shared Services
- `src/services/casino/CasinoRNGService.ts` - Random number generation
- `src/services/casino/CasinoAudioService.ts` - Sound management
- `src/services/casino/BalanceService.ts` - Balance validation
- `src/services/casino/HapticFeedbackService.ts` - Vibration patterns

### Shared Components
- `src/components/casino/shared/GameLayout.tsx` - Page structure
- `src/components/casino/shared/CoinDisplay.tsx` - Balance display
- `src/components/casino/shared/TouchButton.tsx` - Mobile buttons
- `src/components/casino/shared/TouchFeedback.tsx` - Press animations

### Shared Hooks
- `src/hooks/casino/useCasinoBalance.ts` - Balance management
- `src/hooks/casino/useCasinoAudio.ts` - Audio integration
- `src/hooks/casino/useHapticFeedback.ts` - Device vibration
- `src/hooks/casino/useTouchGestures.ts` - Mobile interactions

## Detailed Implementation Steps

### Phase 1: Core Game Logic Implementation

#### Step 1.1: Slot Game Service
Create the main game logic service handling spin cycles, balance validation, and win detection.

```typescript
// src/services/casino/slots/SlotGameService.ts
export class SlotGameService {
  private rngService: SlotRNGService
  private winDetection: WinDetectionService
  private nearMissService: NearMissService

  public async executeSpin(wager: number, balance: number): Promise<SlotSpinResult> {
    // Validate bet amount
    if (balance < wager) {
      return { success: false, error: 'Insufficient balance' }
    }

    // Generate reel symbols using weighted RNG
    const reelSymbols = await this.rngService.generateReelResult()
    
    // Check for wins and calculate payouts
    const winResult = this.winDetection.evaluateWin(reelSymbols, wager)
    
    // Apply near-miss effects (18% of losing spins)
    const nearMiss = !winResult.isWin && this.nearMissService.shouldApplyNearMiss()

    return {
      success: true,
      symbols: reelSymbols,
      winAmount: winResult.totalPayout,
      isWin: winResult.isWin,
      isNearMiss: nearMiss,
      celebrationLevel: this.determineCelebrationLevel(winResult.totalPayout, wager)
    }
  }
}
```

#### Step 1.2: Weighted Random Number Generation
Implement cryptographically secure RNG with chess piece probability distribution.

```typescript
// src/services/casino/slots/SlotRNGService.ts
export class SlotRNGService {
  private generateSecureRandom(): number {
    const array = new Uint32Array(1)
    crypto.getRandomValues(array)
    return array[0] / (0xFFFFFFFF + 1)
  }

  public generateSymbol(): ChessSymbol {
    const random = this.generateSecureRandom()
    let cumulativeWeight = 0

    for (const [symbol, weight] of Object.entries(CHESS_SYMBOL_WEIGHTS)) {
      cumulativeWeight += weight
      if (random <= cumulativeWeight) {
        return symbol as ChessSymbol
      }
    }

    return '♙' // Fallback to pawn
  }

  public generateReelResult(): [ChessSymbol, ChessSymbol, ChessSymbol] {
    return [
      this.generateSymbol(),
      this.generateSymbol(),
      this.generateSymbol()
    ]
  }
}
```

#### Step 1.3: Win Detection System
Implement single-payline win detection optimized for mobile screens.

```typescript
// src/services/casino/slots/WinDetectionService.ts
export class WinDetectionService {
  private readonly PAYLINE = [1, 1, 1] // Center line only for mobile

  public evaluateWin(symbols: ChessSymbol[], wager: number): WinEvaluationResult {
    const [left, center, right] = symbols

    // Check for three-of-a-kind (only winning combination)
    if (left === center && center === right) {
      const multiplier = CHESS_PAYOUTS[left] || 0
      return {
        isWin: true,
        winningSymbol: left,
        totalPayout: wager * multiplier,
        paylineMatches: [{ line: this.PAYLINE, symbol: left, multiplier }]
      }
    }

    return {
      isWin: false,
      winningSymbol: null,
      totalPayout: 0,
      paylineMatches: []
    }
  }
}
```

### Phase 2: React Component Implementation

#### Step 2.1: Main Slots Page Component
Create the container component that orchestrates the entire slots experience.

```typescript
// src/pages/casino/SlotsPage.tsx
export const SlotsPage: React.FC = () => {
  const { balance, placeBet, addWinnings } = useCasinoBalance()
  const { startGameSession, endGameSession } = useCasinoStore()
  
  useEffect(() => {
    startGameSession('slots')
    return () => endGameSession()
  }, [startGameSession, endGameSession])

  return (
    <GameLayout title="Slots" gameType="slots">
      <div className="slots-page min-h-screen bg-gradient-to-b from-slate-900 to-slate-800">
        {/* Header with balance display */}
        <div className="safe-area-top px-4 py-3 bg-slate-800/50">
          <CoinDisplay 
            amount={balance} 
            size="large"
            className="text-center"
          />
        </div>

        {/* Main slot machine */}
        <div className="flex-1 flex items-center justify-center p-4">
          <EnhancedSlotMachine
            onBetPlaced={placeBet}
            onWinnings={addWinnings}
            maxWager={Math.min(100, balance)}
          />
        </div>

        {/* Footer with game info */}
        <div className="safe-area-bottom p-4 bg-slate-800/30">
          <div className="text-center text-sm text-slate-400">
            Single payline • 3 reels • Chess theme
          </div>
        </div>
      </div>
    </GameLayout>
  )
}
```

#### Step 2.2: Enhanced Slot Machine Component
The core slot machine with mobile-optimized controls and animations.

```typescript
// src/components/casino/slots/EnhancedSlotMachine.tsx
export const EnhancedSlotMachine: React.FC<SlotMachineProps> = ({
  onBetPlaced,
  onWinnings,
  maxWager
}) => {
  const { 
    spin, 
    isSpinning, 
    reels, 
    winResult,
    wager,
    setWager 
  } = useSlotMachine()
  
  const { playSound } = useCasinoAudio()
  const { vibrate } = useHapticFeedback()
  const springProps = useSlotAnimations(isSpinning, reels)

  const handleSpin = useCallback(async () => {
    if (isSpinning || wager > maxWager) return

    // Place bet through casino store
    const betSuccess = onBetPlaced(wager)
    if (!betSuccess) {
      vibrate('error')
      return
    }

    // Execute spin with audio feedback
    playSound('spinStart')
    vibrate('spin')
    
    const result = await spin(wager)
    
    if (result.isWin) {
      playSound(result.celebrationLevel === 'big' ? 'winBig' : 'winSmall')
      vibrate(result.celebrationLevel === 'big' ? 'bigWin' : 'smallWin')
      onWinnings(result.winAmount)
    } else {
      playSound('spinEnd')
    }
  }, [isSpinning, wager, maxWager, onBetPlaced, spin, playSound, vibrate, onWinnings])

  return (
    <div 
      className="enhanced-slot-machine max-w-sm mx-auto bg-gradient-to-b from-slate-700 to-slate-800 rounded-2xl shadow-2xl overflow-hidden"
      style={{
        // Safe area handling for notched devices
        paddingTop: 'env(safe-area-inset-top)',
        paddingBottom: 'env(safe-area-inset-bottom)',
      }}
    >
      {/* Reels Display */}
      <div className="reels-container p-6 bg-gradient-to-b from-slate-600 to-slate-700">
        <div className="flex justify-center space-x-4 mb-4">
          {reels.map((symbol, index) => (
            <SlotReel
              key={index}
              symbol={symbol}
              isSpinning={isSpinning}
              delay={REEL_STOP_DELAYS[index]}
              style={{
                willChange: 'transform',
                ...springProps[index]
              }}
              className="slot-reel"
            />
          ))}
        </div>

        {/* Win line indicator */}
        <WinLineIndicator 
          isVisible={winResult?.isWin} 
          symbols={reels}
        />
      </div>

      {/* Game Controls */}
      <div className="controls-section p-6 space-y-4">
        {/* Bet Controls */}
        <BetControls
          wager={wager}
          onWagerChange={setWager}
          minWager={1}
          maxWager={maxWager}
        />

        {/* Spin Button */}
        <SpinButton
          onClick={handleSpin}
          disabled={isSpinning || wager > maxWager}
          isSpinning={isSpinning}
          wager={wager}
        />
      </div>

      {/* Win Celebration Overlay */}
      {winResult?.isWin && (
        <WinCelebration
          winAmount={winResult.winAmount}
          celebrationLevel={winResult.celebrationLevel}
          winningSymbol={winResult.winningSymbol}
        />
      )}
    </div>
  )
}
```

#### Step 2.3: Individual Reel Component
Physics-based spinning reel with staggered stopping animation.

```typescript
// src/components/casino/slots/SlotReel.tsx
export const SlotReel: React.FC<SlotReelProps> = ({
  symbol,
  isSpinning,
  delay,
  style,
  className
}) => {
  const springProps = useSpring({
    transform: isSpinning 
      ? 'translateY(-2000px)' // 2000px spin distance for dramatic effect
      : 'translateY(0px)',
    config: {
      tension: 120,    // Spring physics for realistic deceleration
      friction: 14,    // Damping for smooth stop
      clamp: true      // Prevent overshoot
    },
    delay: isSpinning ? 0 : delay, // Staggered stopping
  })

  return (
    <div className={`reel-container ${className}`}>
      <animated.div 
        className="reel-content"
        style={{
          ...springProps,
          ...style,
          willChange: 'transform' // Hardware acceleration hint
        }}
      >
        {/* Symbol display with blur effect during spinning */}
        <div 
          className={`
            reel-symbol w-20 h-20 flex items-center justify-center
            bg-gradient-to-b from-white to-slate-100 
            rounded-lg shadow-lg border-2 border-slate-300
            transition-all duration-200
            ${isSpinning ? 'blur-sm' : 'blur-0'}
          `}
        >
          <span 
            className="chess-symbol text-4xl font-bold text-slate-800"
            style={{
              textShadow: '0 2px 4px rgba(0, 0, 0, 0.3)',
              filter: isSpinning ? 'blur(1px)' : 'none'
            }}
          >
            {symbol}
          </span>
        </div>
      </animated.div>
    </div>
  )
}
```

### Phase 3: Mobile-First Design Implementation

#### Step 3.1: Touch-Optimized Bet Controls
Mobile-first bet adjustment with hold-to-repeat functionality.

```typescript
// src/components/casino/slots/BetControls.tsx
export const BetControls: React.FC<BetControlsProps> = ({
  wager,
  onWagerChange,
  minWager,
  maxWager
}) => {
  const { handleTouchStart, handleTouchEnd, isLongPressing } = useTouchGestures()
  const { vibrate } = useHapticFeedback()

  const adjustBet = useCallback((delta: number) => {
    const newWager = Math.max(minWager, Math.min(maxWager, wager + delta))
    if (newWager !== wager) {
      onWagerChange(newWager)
      vibrate('spin')
    }
  }, [wager, minWager, maxWager, onWagerChange, vibrate])

  // Hold-to-repeat with 500ms threshold
  const startDecrease = useCallback(() => {
    handleTouchStart(() => adjustBet(-1))
  }, [handleTouchStart, adjustBet])

  const startIncrease = useCallback(() => {
    handleTouchStart(() => adjustBet(1))
  }, [handleTouchStart, adjustBet])

  return (
    <div className="bet-controls flex items-center justify-center space-x-4">
      {/* Decrease Button */}
      <TouchButton
        size="large"
        variant="secondary"
        onTouchStart={startDecrease}
        onMouseDown={startDecrease}
        onTouchEnd={handleTouchEnd}
        onMouseUp={handleTouchEnd}
        disabled={wager <= minWager}
        className="w-14 h-14 rounded-full"
        hapticFeedback="spin"
      >
        <Minus className="w-6 h-6" />
      </TouchButton>

      {/* Wager Display */}
      <div className="bet-display flex flex-col items-center px-6">
        <div className="text-sm text-slate-400 uppercase tracking-wide">
          Bet
        </div>
        <div className="flex items-center space-x-2">
          <Coins className="w-5 h-5 text-yellow-400" />
          <span className="text-3xl font-bold text-white">
            {wager}
          </span>
        </div>
      </div>

      {/* Increase Button */}
      <TouchButton
        size="large"
        variant="secondary"
        onTouchStart={startIncrease}
        onMouseDown={startIncrease}
        onTouchEnd={handleTouchEnd}
        onMouseUp={handleTouchEnd}
        disabled={wager >= maxWager}
        className="w-14 h-14 rounded-full"
        hapticFeedback="spin"
      >
        <Plus className="w-6 h-6" />
      </TouchButton>
    </div>
  )
}
```

#### Step 3.2: Mobile-Optimized Spin Button
Large, accessible spin button with clear visual feedback.

```typescript
// src/components/casino/slots/SpinButton.tsx
export const SpinButton: React.FC<SpinButtonProps> = ({
  onClick,
  disabled,
  isSpinning,
  wager
}) => {
  const { vibrate } = useHapticFeedback()
  const [isPressed, setIsPressed] = useState(false)

  const buttonSpring = useSpring({
    scale: isPressed ? 0.95 : 1.0,
    backgroundColor: disabled 
      ? '#64748b' // slate-500
      : isSpinning 
        ? '#f59e0b' // amber-500 
        : '#10b981', // emerald-500
    config: { duration: 150 }
  })

  const spinnerSpring = useSpring({
    transform: isSpinning ? 'rotate(360deg)' : 'rotate(0deg)',
    config: { duration: 1000 }
  })

  const handlePress = useCallback(() => {
    if (disabled) {
      vibrate('error')
      return
    }

    setIsPressed(true)
    vibrate('spin')
    onClick()

    // Reset press state after animation
    setTimeout(() => setIsPressed(false), 150)
  }, [disabled, onClick, vibrate])

  return (
    <animated.button
      className={`
        spin-button relative overflow-hidden
        w-full h-16 rounded-xl font-bold text-xl
        shadow-lg active:shadow-inner
        transition-all duration-150
        focus:outline-none focus:ring-4 focus:ring-blue-300
        disabled:cursor-not-allowed
        ${disabled ? 'opacity-50' : 'opacity-100'}
      `}
      style={buttonSpring}
      onClick={handlePress}
      disabled={disabled}
      aria-label={`Spin reels for ${wager} coins`}
    >
      {/* Button Content */}
      <div className="flex items-center justify-center space-x-3">
        {isSpinning ? (
          <>
            <animated.div style={spinnerSpring}>
              <Loader className="w-6 h-6" />
            </animated.div>
            <span>Spinning...</span>
          </>
        ) : (
          <>
            <Play className="w-6 h-6" />
            <span>SPIN</span>
          </>
        )}
      </div>

      {/* Shimmer effect for available spins */}
      {!disabled && !isSpinning && (
        <div className="absolute inset-0 bg-gradient-to-r from-transparent via-white/20 to-transparent animate-shimmer" />
      )}
    </animated.button>
  )
}
```

### Phase 4: Audio Integration

#### Step 4.1: Slots-Specific Audio Events
Integration with the existing casino audio system for slots-specific sounds.

```typescript
// src/constants/casino/slots/audio.constants.ts
export const SLOTS_AUDIO_EVENTS = {
  spinStart: 'spin-start',     // Reel spinning begins
  spinStop: 'spin-stop',       // Individual reel stops
  spinEnd: 'spin-complete',    // All reels stopped
  winSmall: 'win-small',       // Small win celebration
  winBig: 'win-big',           // Big win celebration
  winJackpot: 'win-jackpot',   // King symbol jackpot
  nearMiss: 'near-miss',       // Near-miss effect
  betAdjust: 'bet-adjust',     // Bet amount change
  buttonPress: 'button-press', // UI button feedback
} as const

// Audio timing configuration
export const SLOTS_AUDIO_CONFIG = {
  spinDuration: 2500,          // Total spin sound duration
  reelStopDelay: 200,          // Delay between reel stops
  winCelebrationDuration: 3000, // Win sound duration
  maxConcurrentSounds: 4,      // Prevent audio overload
  volumeLevels: {
    effects: 0.8,              // Game effect volume
    ambient: 0.3,              // Background volume
    celebration: 1.0           // Win celebration volume
  }
} as const
```

#### Step 4.2: Audio Integration Hook
Custom hook for slots-specific audio management.

```typescript
// src/hooks/casino/slots/useSlotsAudio.ts
export const useSlotsAudio = () => {
  const { playSound, preloadSounds, setVolume } = useCasinoAudio()

  useEffect(() => {
    // Preload essential slots sounds
    preloadSounds([
      SLOTS_AUDIO_EVENTS.spinStart,
      SLOTS_AUDIO_EVENTS.spinEnd,
      SLOTS_AUDIO_EVENTS.winSmall,
      SLOTS_AUDIO_EVENTS.winBig,
    ])
  }, [preloadSounds])

  const playSpin = useCallback(() => {
    playSound(SLOTS_AUDIO_EVENTS.spinStart, {
      volume: SLOTS_AUDIO_CONFIG.volumeLevels.effects,
      duration: SLOTS_AUDIO_CONFIG.spinDuration
    })
  }, [playSound])

  const playReelStop = useCallback((reelIndex: number) => {
    // Staggered reel stop sounds
    setTimeout(() => {
      playSound(SLOTS_AUDIO_EVENTS.spinStop, {
        volume: SLOTS_AUDIO_CONFIG.volumeLevels.effects * 0.7,
        pitch: 1.0 + (reelIndex * 0.1) // Slightly different pitch per reel
      })
    }, reelIndex * SLOTS_AUDIO_CONFIG.reelStopDelay)
  }, [playSound])

  const playWin = useCallback((celebrationLevel: 'small' | 'big' | 'jackpot') => {
    const soundMap = {
      small: SLOTS_AUDIO_EVENTS.winSmall,
      big: SLOTS_AUDIO_EVENTS.winBig,
      jackpot: SLOTS_AUDIO_EVENTS.winJackpot
    }

    playSound(soundMap[celebrationLevel], {
      volume: SLOTS_AUDIO_CONFIG.volumeLevels.celebration,
      duration: SLOTS_AUDIO_CONFIG.winCelebrationDuration
    })
  }, [playSound])

  const playNearMiss = useCallback(() => {
    // Subtle audio cue for near-miss
    playSound(SLOTS_AUDIO_EVENTS.nearMiss, {
      volume: SLOTS_AUDIO_CONFIG.volumeLevels.effects * 0.5,
      delay: 500 // Play after reels stop
    })
  }, [playSound])

  return {
    playSpin,
    playReelStop,
    playWin,
    playNearMiss,
    playButtonPress: () => playSound(SLOTS_AUDIO_EVENTS.buttonPress, {
      volume: SLOTS_AUDIO_CONFIG.volumeLevels.effects * 0.6
    })
  }
}
```

### Phase 5: Win Celebration System

#### Step 5.1: Win Animation Component
Animated win celebration with scaling and particle effects.

```typescript
// src/components/casino/slots/WinCelebration.tsx
export const WinCelebration: React.FC<WinCelebrationProps> = ({
  winAmount,
  celebrationLevel,
  winningSymbol,
  onComplete
}) => {
  const [isVisible, setIsVisible] = useState(true)

  // Celebration animation springs
  const overlaySpring = useSpring({
    opacity: isVisible ? 1 : 0,
    transform: isVisible ? 'scale(1)' : 'scale(0.8)',
    config: { tension: 200, friction: 20 }
  })

  const winAmountSpring = useSpring({
    from: { number: 0, scale: 0.5 },
    to: { 
      number: winAmount, 
      scale: celebrationLevel === 'big' ? 1.2 : 1.0 
    },
    config: { tension: 120, friction: 14 }
  })

  const symbolSpring = useSpring({
    from: { rotateZ: 0, scale: 1 },
    to: async (next) => {
      // Celebration sequence
      await next({ rotateZ: 360, scale: 1.3 })
      await next({ rotateZ: 720, scale: 1.0 })
      await next({ rotateZ: 1080, scale: 1.1 })
    },
    config: { tension: 180, friction: 12 }
  })

  // Auto-hide after celebration duration
  useEffect(() => {
    const timer = setTimeout(() => {
      setIsVisible(false)
      setTimeout(onComplete, 300) // Wait for fade out
    }, celebrationLevel === 'big' ? 4000 : 2000)

    return () => clearTimeout(timer)
  }, [celebrationLevel, onComplete])

  if (!isVisible && overlaySpring.opacity.get() === 0) {
    return null
  }

  return (
    <animated.div
      className="win-celebration absolute inset-0 flex items-center justify-center bg-black/60 backdrop-blur-sm z-50"
      style={overlaySpring}
    >
      <div className="celebration-content text-center space-y-6">
        {/* Winning Symbol */}
        <animated.div
          className="winning-symbol"
          style={symbolSpring}
        >
          <div className={`
            text-8xl drop-shadow-lg
            ${celebrationLevel === 'big' ? 'text-yellow-400' : 'text-green-400'}
          `}>
            {winningSymbol}
          </div>
        </animated.div>

        {/* Win Text */}
        <div className="win-text space-y-2">
          <div className={`
            text-2xl font-bold uppercase tracking-wider
            ${celebrationLevel === 'big' ? 'text-yellow-400' : 'text-green-400'}
          `}>
            {celebrationLevel === 'big' ? 'BIG WIN!' : 'Winner!'}
          </div>

          {/* Animated Win Amount */}
          <div className="win-amount">
            <animated.div
              className="text-5xl font-bold text-white"
              style={{ 
                transform: winAmountSpring.scale.to(s => `scale(${s})`),
              }}
            >
              <animated.span>
                {winAmountSpring.number.to(n => `${Math.floor(n)}`)}
              </animated.span>
              <span className="text-yellow-400 ml-2">coins</span>
            </animated.div>
          </div>
        </div>

        {/* Triple Symbol Display */}
        <div className="winning-combination flex justify-center space-x-4">
          {[0, 1, 2].map((index) => (
            <animated.div
              key={index}
              className="symbol-box w-16 h-16 bg-white/20 rounded-lg flex items-center justify-center"
              style={{
                animationDelay: `${index * 0.2}s`,
                ...symbolSpring
              }}
            >
              <span className="text-3xl">{winningSymbol}</span>
            </animated.div>
          ))}
        </div>

        {/* Celebration Particles */}
        {celebrationLevel === 'big' && (
          <div className="celebration-particles">
            <ParticleSystem
              particleCount={50}
              colors={['#fbbf24', '#f59e0b', '#d97706']}
              duration={3000}
            />
          </div>
        )}
      </div>
    </animated.div>
  )
}
```

## Mobile-First Design Considerations

### Touch Interface Optimization
- **Minimum Touch Targets**: 44x44px (iOS HIG compliance)
- **Touch Response**: <16ms visual feedback
- **Hold-to-Repeat**: 500ms threshold for bet adjustments
- **Gesture Support**: Tap, long-press, prevent accidental touches
- **Haptic Feedback**: Coordinated with visual feedback

### Safe Area Handling
```css
.slots-page {
  padding-top: env(safe-area-inset-top);
  padding-bottom: env(safe-area-inset-bottom);
  padding-left: env(safe-area-inset-left);
  padding-right: env(safe-area-inset-right);
}
```

### Responsive Layout Breakpoints
- **Mobile Portrait**: 320px - 414px (primary target)
- **Mobile Landscape**: 568px - 896px
- **Tablet**: 768px - 1024px
- **Desktop**: 1025px+ (secondary target)

### Performance Optimizations
- **Hardware Acceleration**: `will-change: transform` on animated elements
- **Layer Optimization**: Minimize paint operations during animations
- **Memory Management**: Cleanup intervals and event listeners
- **Battery Efficiency**: Pause animations when page not visible

## Audio Integration with Existing Library

### Sound File Requirements
All audio files should be located in `/public/sounds/casino/` directory:

```
public/sounds/casino/slots/
├── spin-start.mp3      # Reel spinning begins (1.5s)
├── spin-stop.mp3       # Individual reel stops (0.3s)
├── spin-complete.mp3   # All reels stopped (0.5s)
├── win-small.mp3       # Small win celebration (1s)
├── win-big.mp3         # Big win celebration (2s)
├── win-jackpot.mp3     # King symbol jackpot (3s)
├── near-miss.mp3       # Near-miss effect (0.5s)
├── bet-adjust.mp3      # Bet change feedback (0.2s)
└── button-press.mp3    # UI button press (0.1s)
```

### Audio Configuration
- **File Format**: MP3, 64kbps, Mono
- **File Size**: <50KB per file
- **Sample Rate**: 44.1kHz
- **Compression**: Optimized for mobile bandwidth

### Integration with CasinoAudioService
```typescript
// Extend existing audio service for slots
const slotsAudioEvents = {
  ...EXISTING_CASINO_AUDIO_EVENTS,
  ...SLOTS_AUDIO_EVENTS
}

// Preload slots sounds on game initialization
await casinoAudioService.preloadSounds([
  'slots/spin-start',
  'slots/win-small',
  'slots/win-big'
])
```

## Testing Requirements

### Unit Testing
- **Game Logic**: Win detection accuracy, payout calculations
- **RNG Testing**: Statistical distribution validation
- **Component Testing**: Render states, user interactions
- **Hook Testing**: State management, side effects

### Integration Testing
- **Audio Integration**: Sound playback coordination
- **Animation Timing**: Sequence validation
- **Balance Updates**: Casino store integration
- **Mobile Interactions**: Touch gesture handling

### Performance Testing
- **Frame Rate**: Consistent 60fps during animations
- **Memory Usage**: No memory leaks during extended play
- **Touch Latency**: <16ms response time measurement
- **Battery Impact**: Power consumption monitoring

### Accessibility Testing
- **Screen Readers**: ARIA labels and descriptions
- **Keyboard Navigation**: Tab order and focus management
- **High Contrast**: Color contrast ratios (4.5:1 minimum)
- **Reduced Motion**: Animation disable functionality

### Manual Testing Scenarios
1. **Spin Cycle**: Complete spin with win/loss outcomes
2. **Balance Validation**: Insufficient funds handling
3. **Audio Feedback**: Sound coordination with actions
4. **Touch Interactions**: Multi-touch gesture prevention
5. **Orientation Changes**: Layout adaptation
6. **Network Interruption**: State persistence
7. **Background/Foreground**: Animation pause/resume

## Success Criteria

### Functional Requirements
- ✅ Chess-themed symbols with proper probabilities
- ✅ Single payline win detection
- ✅ Balance integration with casino store
- ✅ Mobile-optimized touch controls
- ✅ Audio feedback for all interactions
- ✅ Win celebration animations

### Performance Requirements
- ✅ 60fps animations during gameplay
- ✅ <16ms touch response time
- ✅ <200KB additional bundle size
- ✅ <2s initial load time
- ✅ Smooth animations on mid-range devices

### Accessibility Requirements
- ✅ WCAG 2.1 AA compliance
- ✅ Screen reader compatibility
- ✅ High contrast mode support
- ✅ Reduced motion preferences
- ✅ Keyboard navigation support

### User Experience Requirements
- ✅ Intuitive touch interactions
- ✅ Clear visual feedback
- ✅ Professional casino aesthetic
- ✅ Engaging win celebrations
- ✅ Consistent with casino theme

This comprehensive implementation plan provides all the necessary details to build a professional-grade, mobile-first chess-themed slots game that integrates seamlessly with the existing casino infrastructure while maintaining high performance and accessibility standards.