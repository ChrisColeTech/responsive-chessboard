# Casino Enhancement Implementation - Document 45.0.3

## Work Progress Tracking Table

| Phase | Status | Priority | Description |
|-------|--------|----------|-------------|
| Phase 1: Shared Casino Infrastructure | ðŸŸ¡ Planned | 1 (Highest) | Core utilities, types, services, and hooks for ALL casino games |
| Phase 2: RNG & Game Logic Foundation | ðŸŸ¡ Planned | 2 (Highest) | Random number generation, win detection, payout calculations |
| Phase 3: Shared Components & Animations | ðŸŸ¡ Planned | 3 (Highest) | React Spring integration, shared UI components (BetControls, CoinDisplay, etc.) |
| Phase 4: Audio & Haptics System | ðŸŸ¡ Planned | 4 (High) | Web Audio API, haptic feedback, sound management |
| Phase 5: Balance & State Management | ðŸŸ¡ Planned | 5 (High) | Enhanced Zustand casino store, persistence, validation |
| Phase 6: Casino Index Page | ðŸŸ¡ Planned | 6 (High) | Main casino page with game selection, stats, and navigation |
| Phase 7: Enhanced Slots Page | ðŸŸ¡ Planned | 7 (High) | Complete slot machine implementation using shared infrastructure |
| Phase 8: Mobile Optimization | ðŸŸ¡ Planned | 8 (Medium) | Touch gestures, performance, battery optimization |
| Phase 9: Blackjack Game | ðŸŸ¡ Planned | 9 (Medium) | Single-player blackjack page using shared casino services |
| Phase 10: Texas Hold'em Game | ðŸŸ¡ Planned | 10 (Medium) | Single-player Texas Hold'em poker using shared infrastructure |
| Phase 11: Roulette Game | ðŸŸ¡ Planned | 11 (Medium) | American/European roulette with betting table and wheel physics |
| Phase 12: Craps Game | ðŸŸ¡ Planned | 12 (Medium) | Simplified craps with dice simulation and betting options |
| Phase 13: PWA Features | ðŸŸ¡ Planned | 13 (Low) | Service workers, offline play, installation |

## Project Structure Overview

```
src/
â”œâ”€â”€ components/
â”‚   â””â”€â”€ casino/              # Casino game components
â”‚       â”œâ”€â”€ shared/          # Shared UI components (BetControls, CoinDisplay, etc.)
â”‚       â”œâ”€â”€ slots/           # Slot machine specific components
â”‚       â”œâ”€â”€ blackjack/       # Blackjack specific components
â”‚       â”œâ”€â”€ holdem/          # Texas Hold'em specific components
â”‚       â”œâ”€â”€ roulette/        # Roulette specific components
â”‚       â””â”€â”€ craps/           # Craps specific components
â”œâ”€â”€ hooks/
â”‚   â””â”€â”€ casino/              # Casino-specific React hooks (useCasinoAudio, useSlotMachine, etc.)
â”œâ”€â”€ services/
â”‚   â””â”€â”€ casino/              # Casino game logic and external services (RNG, PayoutCalculation, etc.)
â”œâ”€â”€ types/
â”‚   â””â”€â”€ casino/              # Casino TypeScript type definitions
â”œâ”€â”€ utils/
â”‚   â””â”€â”€ casino/              # Casino pure utility functions (currency, validation, etc.)
â”œâ”€â”€ constants/
â”‚   â””â”€â”€ casino/              # Casino game configuration constants (payouts, symbols, etc.)
â”œâ”€â”€ animations/
â”‚   â””â”€â”€ casino/              # Casino React Spring animation configs
â”œâ”€â”€ pages/
â”‚   â””â”€â”€ casino/              # Casino pages
â”‚       â”œâ”€â”€ CasinoIndexPage.tsx  # Main casino page with game selection and overview
â”‚       â”œâ”€â”€ SlotsPage.tsx        # Enhanced slots page using shared casino infrastructure
â”‚       â”œâ”€â”€ BlackjackPage.tsx    # Blackjack page using shared casino services  
â”‚       â”œâ”€â”€ HoldemPage.tsx       # Texas Hold'em page using shared casino infrastructure
â”‚       â”œâ”€â”€ RoulettePage.tsx     # Roulette page with betting table and wheel
â”‚       â””â”€â”€ CrapsPage.tsx        # Craps page with dice simulation and betting
â””â”€â”€ stores/
    â””â”€â”€ casinoStore.ts       # Casino-specific Zustand store (shared across all games)
```

## Phase 1: Foundation (Priority 1 - Highest)

### Overview
Establish core infrastructure for casino games including types, utilities, services, and foundational hooks following SRP and DRY principles.

### Files to Create
- `src/types/casino/index.ts`
- `src/types/casino/slot-machine.types.ts`
- `src/types/casino/casino-game.types.ts`
- `src/types/casino/audio.types.ts`
- `src/utils/casino/index.ts`
- `src/utils/casino/random.utils.ts`
- `src/utils/casino/currency.utils.ts`
- `src/utils/casino/validation.utils.ts`
- `src/constants/casino/index.ts`
- `src/constants/casino/slot-symbols.constants.ts`
- `src/constants/casino/payout-tables.constants.ts`
- `src/services/casino/index.ts`
- `src/services/casino/CasinoRNGService.ts`
- `src/hooks/casino/index.ts`
- `src/hooks/casino/useCasinoAudio.ts`
- `src/hooks/casino/useHapticFeedback.ts`

### Files to Modify
- `src/types/index.ts` (add casino type exports)
- `src/components/layout/types.ts` (add casino tab types)

### Integration Points (Files Used But Not Modified)
- `src/stores/appStore.ts` (for coinBalance state)
- `src/services/audio/audioService.ts` (for base audio functionality)
- `src/components/layout/TabBar.tsx` (existing casino tab)

### Key Deliverables
1. **Type System**: Complete TypeScript definitions for all casino games
2. **Crypto RNG**: `crypto.getRandomValues()` implementation replacing `Math.random()` for provably fair gaming
3. **Currency Utils**: Chess-themed coin formatting with comma separators, balance validation (minimum 0)
4. **Audio Foundation**: Web Audio API setup with 64kbps MP3 compression, <50KB file sizes, audio pooling
5. **Haptic System**: Vibration API patterns - `[200]` for wins, `[100,50,100]` for big wins, with user toggle

### Implementation Code

**CasinoRNGService.ts**:
```typescript
// Cryptographically secure RNG
const generateSecureRandom = (): number => {
  const array = new Uint32Array(1)
  crypto.getRandomValues(array)
  return array[0] / (0xFFFFFFFF + 1)
}

// Weighted symbol selection with chess pieces
const CHESS_SYMBOL_WEIGHTS = {
  'â™”': 0.05, // King - 5% (rarest)
  'â™•': 0.08, // Queen - 8%
  'â™–': 0.12, // Rook - 12%
  'â™—': 0.15, // Bishop - 15%
  'â™˜': 0.15, // Knight - 15%
  'â™™': 0.20, // Pawn - 20% (most common)
  // Black pieces with same weights
}
```

**hooks/casino/useCasinoAudio.ts**:
```typescript
// Battery-efficient audio with preloading
const AUDIO_CONFIG = {
  spinSound: { duration: 1.5, volume: 0.8 },
  winSound: { duration: 0.5, volume: 1.0 },
  ambientVolume: 0.2, // 20% background, 80% effects
  maxConcurrentSounds: 3
}
```

**hooks/casino/useHapticFeedback.ts**:
```typescript
// Vibration patterns from research
const HAPTIC_PATTERNS = {
  spin: [100],
  smallWin: [200],
  bigWin: [100, 50, 100, 50, 200],
  maxDuration: 500 // Battery optimization
}
```

## Phase 2: RNG & Game Logic (Priority 2 - High)

### Overview
Implement core game logic systems including weighted randomization, win detection, and payout calculations.

### Files to Create
- `src/services/casino/SlotGameLogic.ts`
- `src/services/casino/WinDetectionService.ts`
- `src/services/casino/PayoutCalculationService.ts`
- `src/utils/casino/slot-game.utils.ts`
- `src/utils/casino/probability.utils.ts`
- `src/hooks/casino/useSlotMachine.ts`
- `src/constants/casino/slot-paylines.constants.ts`
- `src/constants/casino/win-combinations.constants.ts`

### Files to Modify
- `src/services/casino/index.ts` (add exports)
- `src/hooks/casino/index.ts` (add exports)

### Integration Points
- `src/services/casino/CasinoRNGService.ts` (from Phase 1)
- `src/constants/casino/payout-tables.constants.ts` (from Phase 1)
- `src/stores/appStore.ts` (for balance updates)

### Key Deliverables
1. **Weighted RNG**: Chess piece probability distribution with near-miss logic (15-20% of losing spins)
2. **Payline Evaluation**: Single center line `[1,1,1]` optimized for mobile screens
3. **Chess Payout System**: Pawn=2x, Rook=5x, Knight=8x, Bishop=10x, Queen=25x, King=100x
4. **Game Hook**: Complete slot machine cycle with balance validation and win celebration
5. **Mathematical Testing**: RTP verification and randomness validation with deterministic seeds

### Implementation Code

**services/casino/SlotGameLogic.ts**:
```typescript
// Chess-themed payout table from research
const CHESS_PAYOUTS = {
  'â™™â™™â™™': 2,   // Triple Pawn
  'â™–â™–â™–': 5,   // Triple Rook 
  'â™˜â™˜â™˜': 8,   // Triple Knight
  'â™—â™—â™—': 10,  // Triple Bishop
  'â™•â™•â™•': 25,  // Triple Queen
  'â™”â™”â™”': 100, // Triple King (jackpot)
}

// Near-miss implementation
const generateNearMiss = (symbols: string[]): boolean => {
  return Math.random() < 0.18 // 18% near-miss rate
}
```

**services/casino/WinDetectionService.ts**:
```typescript
// Single payline for mobile optimization
const MOBILE_PAYLINES = [
  [1, 1, 1] // Center line only for 3-reel mobile slot
]

// Win detection with visual feedback timing
const detectWin = (reels: string[]): WinResult => {
  const winAmount = CHESS_PAYOUTS[reels.join('')] || 0
  return {
    isWin: winAmount > 0,
    amount: winAmount,
    highlightDuration: 2000, // 2s win animation
    celebrationLevel: winAmount >= 25 ? 'big' : 'small'
  }
}
```

**hooks/casino/useSlotMachine.ts**:
```typescript
// Complete game cycle with research-based timing
const useSlotMachine = () => {
  const [isSpinning, setIsSpinning] = useState(false)
  const [reels, setReels] = useState(['â™”', 'â™›', 'â™–'])
  
  const spin = useCallback(async () => {
    if (balance < wager) return // Balance validation
    
    setIsSpinning(true)
    setCoinBalance(prev => prev - wager) // Deduct immediately
    
    // 2-3 second spin with 200-300ms stagger
    await animateReels(2500, [0, 200, 400]) // Stagger delays
    
    const result = generateSpinResult()
    setReels(result.symbols)
    
    if (result.isWin) {
      setCoinBalance(prev => prev + result.winAmount)
      triggerWinCelebration(result.celebrationLevel)
    }
    
    setIsSpinning(false)
  }, [balance, wager])
}
```

## Phase 3: Animation System (Priority 3 - High)

### Overview
Implement React Spring-based animation system for smooth, performant mobile gaming experiences.

### Files to Create
- `src/animations/casino/index.ts`
- `src/animations/casino/slot-reel.animations.ts`
- `src/animations/casino/win-celebration.animations.ts`
- `src/animations/casino/ui-feedback.animations.ts`
- `src/hooks/casino/useSlotAnimations.ts`
- `src/hooks/casino/useSpringTransitions.ts`
- `src/components/casino/shared/AnimatedCounter.tsx`
- `src/components/casino/shared/SpringTransition.tsx`

### Files to Modify
- `src/hooks/casino/index.ts` (add animation hooks)
- `src/components/casino/shared/index.ts` (create and add exports)

### Integration Points
- `src/hooks/casino/useSlotMachine.ts` (from Phase 2)
- `src/hooks/casino/useHapticFeedback.ts` (from Phase 1)
- React Spring library (external dependency)

### Key Deliverables
1. **React Spring Reels**: Hardware-accelerated spinning with `transform: translateY()` and spring physics
2. **Win Celebrations**: Scale/rotate effects for winning symbols, glowing borders, 1-2 second animations
3. **Touch Feedback**: 16ms response time with visual feedback (scale animation on tap)
4. **60fps Performance**: `will-change: transform`, easing curves (`ease-out`), <16ms render times
5. **Mobile Optimized**: Reduced motion accessibility option, prevent motion sickness patterns

### Implementation Code

**animations/casino/slot-reel.animations.ts**:
```typescript
// Hardware-accelerated spinning from research
const useReelSpring = (isSpinning: boolean, symbols: string[]) => {
  const springProps = useSpring({
    transform: isSpinning 
      ? 'translateY(-2000px)' // 2000px spin distance
      : 'translateY(0px)',
    config: {
      tension: 120,
      friction: 14,
      // Realistic deceleration curve
    },
    onRest: () => {
      // Reel stopped, trigger next reel with 200ms delay
    }
  })
  
  return {
    ...springProps,
    willChange: 'transform', // Hardware acceleration hint
  }
}

// Staggered reel stopping (authentic casino feel)
const REEL_STOP_DELAYS = [0, 200, 400] // ms between reel stops
```

**animations/casino/win-celebration.animations.ts**:
```typescript
// Win animation patterns from research
const useWinAnimation = (isWinning: boolean, winLevel: 'small' | 'big') => {
  const celebration = useSpring({
    scale: isWinning ? 1.1 : 1.0,
    rotateZ: isWinning ? 5 : 0,
    boxShadow: isWinning 
      ? '0 0 20px rgba(255, 215, 0, 0.8)' // Golden glow
      : '0 0 0px rgba(255, 215, 0, 0)',
    config: { duration: winLevel === 'big' ? 2000 : 1000 }
  })
  
  return celebration
}

// Near-miss "hesitation" effect
const useNearMissEffect = (isNearMiss: boolean) => {
  return useSpring({
    transform: isNearMiss 
      ? 'translateY(-10px) translateY(0px)' // Brief hesitation
      : 'translateY(0px)',
    config: { tension: 300, friction: 10 }
  })
}
```

**animations/casino/ui-feedback.animations.ts**:
```typescript
// Button feedback with 16ms response target
const useTouchFeedback = (isPressed: boolean) => {
  return useSpring({
    scale: isPressed ? 0.95 : 1.0,
    backgroundColor: isPressed ? '#4ade80' : '#22c55e',
    config: { duration: 150 }, // Sub-16ms response
    immediate: false
  })
}

// Accessibility: Reduced motion support
const useAccessibleAnimation = (normalConfig: any) => {
  const prefersReducedMotion = useMediaQuery('(prefers-reduced-motion: reduce)')
  
  return prefersReducedMotion 
    ? { ...normalConfig, config: { duration: 0 } } // Instant
    : normalConfig
}
```

## Phase 4: Audio & Haptics (Priority 4 - Medium)

### Overview
Enhanced audio system with haptic feedback integration for immersive mobile gaming experience.

### Files to Create
- `src/services/casino/CasinoAudioService.ts`
- `src/services/casino/HapticFeedbackService.ts`
- `src/constants/casino/audio-config.constants.ts`
- `src/constants/casino/haptic-patterns.constants.ts`
- `src/utils/casino/audio.utils.ts`

### Files to Modify
- `src/hooks/casino/useCasinoAudio.ts` (enhance from Phase 1)
- `src/hooks/casino/useHapticFeedback.ts` (enhance from Phase 1)
- `src/services/casino/index.ts` (add exports)

### Integration Points
- `src/services/audio/audioService.ts` (base audio system)
- `src/stores/appStore.ts` (audio settings)
- Web Audio API and Vibration API (browser APIs)

### Key Deliverables
1. **Web Audio Integration**: 64kbps MP3 files <50KB each, audio context state detection for silent mode
2. **Haptic Patterns**: Research-specific vibration sequences with 500ms maximum duration
3. **Battery Efficiency**: Audio pooling, preload essential sounds only, pause when page not visible
4. **Cross-Device Audio**: Headphones vs speakers detection, volume mixing (ambient 20%, effects 80%)
5. **Accessibility**: Visual waveform indicators, captions for audio cues, ARIA labels

### Implementation Code

**services/casino/CasinoAudioService.ts**:
```typescript
// Battery-efficient audio from research findings
class CasinoAudioService {
  private audioPool = new Map<string, HTMLAudioElement[]>()
  private maxConcurrentSounds = 3
  
  // Preload only essential sounds (research: avoid background loops)
  async preloadEssentials() {
    const essentialSounds = [
      { id: 'spin', src: '/audio/spin.mp3', duration: 1500 },
      { id: 'win', src: '/audio/win.mp3', duration: 500 },
      { id: 'coin', src: '/audio/coin.mp3', duration: 300 }
    ]
    
    // Create audio pool for reuse
    for (const sound of essentialSounds) {
      this.audioPool.set(sound.id, [])
      for (let i = 0; i < 2; i++) { // Pool of 2 per sound
        const audio = new Audio(sound.src)
        audio.preload = 'auto'
        this.audioPool.get(sound.id)!.push(audio)
      }
    }
  }
  
  // Silent mode detection
  async playSafely(soundId: string, volume = 1.0) {
    if (document.visibilityState === 'hidden') return // Battery optimization
    
    try {
      await this.audioContext.resume() // Handle autoplay policy
      const audioPool = this.audioPool.get(soundId)
      if (!audioPool) return
      
      const availableAudio = audioPool.find(audio => audio.paused)
      if (availableAudio) {
        availableAudio.volume = volume * this.masterVolume
        availableAudio.currentTime = 0
        await availableAudio.play()
      }
    } catch (error) {
      // Graceful fallback - show visual feedback instead
      this.showVisualFeedback(soundId)
    }
  }
}
```

**services/casino/HapticFeedbackService.ts**:
```typescript
// Research-based haptic patterns
const HAPTIC_LIBRARY = {
  // From research: specific patterns for casino events
  spin: [100], // Short tap for spin start
  smallWin: [200], // Medium buzz for small wins
  bigWin: [100, 50, 100, 50, 200], // Complex pattern for big wins
  jackpot: [200, 100, 200, 100, 500], // Dramatic pattern
  error: [50, 50, 50], // Triple short for errors
}

class HapticService {
  private isEnabled = true
  private maxDuration = 500 // Battery optimization from research
  
  async vibrate(pattern: keyof typeof HAPTIC_LIBRARY) {
    if (!this.isEnabled || !navigator.vibrate) return
    
    const vibrationPattern = HAPTIC_LIBRARY[pattern]
    const totalDuration = vibrationPattern.reduce((sum, val) => sum + val, 0)
    
    // Respect battery optimization limit
    if (totalDuration <= this.maxDuration) {
      navigator.vibrate(vibrationPattern)
    }
  }
  
  // User preference toggle
  setEnabled(enabled: boolean) {
    this.isEnabled = enabled
    // Store in localStorage for persistence
    localStorage.setItem('hapticEnabled', enabled.toString())
  }
}
```

**constants/casino/audio-config.constants.ts**:
```typescript
// Research-based audio configuration
export const CASINO_AUDIO_CONFIG = {
  // File optimization from research
  compression: '64kbps', // Mobile data efficiency
  maxFileSize: 50000, // 50KB limit
  formats: ['mp3', 'ogg'], // MP3 primary, OGG fallback
  
  // Volume mixing ratios from research
  volumeMix: {
    ambient: 0.2,  // 20% background
    effects: 0.8,  // 80% sound effects
  },
  
  // Battery optimization settings
  pauseOnHidden: true, // Pause when tab not visible
  maxConcurrent: 3,    // Limit simultaneous sounds
  poolSize: 2,         // Audio instance reuse
  
  // Accessibility features
  visualIndicators: {
    spinSound: 'ðŸŽ° Spinning...',
    winSound: 'ðŸŽ‰ You won!', 
    coinSound: 'ðŸª™ Coins added',
    errorSound: 'âŒ Error occurred'
  }
} as const
```

## Phase 5: Enhanced Slot Components (Priority 5 - Medium)

### Overview
Build complete, functional slot machine components with full game integration.

### Files to Create
- `src/components/casino/slots/EnhancedSlotMachine.tsx`
- `src/components/casino/slots/SlotReel.tsx`
- `src/components/casino/slots/ReelSymbol.tsx`
- `src/components/casino/slots/WinLineIndicator.tsx`
- `src/components/casino/slots/BetControls.tsx`
- `src/components/casino/slots/SpinButton.tsx`
- `src/components/casino/slots/WinCelebration.tsx`
- `src/components/casino/shared/CoinDisplay.tsx`
- `src/components/casino/shared/GameLayout.tsx`

### Files to Modify
- `src/components/casino/slots/index.ts` (create and add exports)
- `src/components/SlotMachine.tsx` (deprecate or refactor)

### Integration Points
- `src/hooks/casino/useSlotMachine.ts` (from Phase 2)
- `src/hooks/casino/useSlotAnimations.ts` (from Phase 3)
- `src/hooks/casino/useCasinoAudio.ts` (from Phase 4)
- `src/stores/appStore.ts` (coin balance)

### Key Deliverables
1. **Touch-Optimized Components**: 44x44px minimum touch targets, 500ms hold-to-repeat betting
2. **Complete Game Integration**: All research findings implemented in working slot machine
3. **Mobile-First Design**: Portrait orientation, safe areas for notched devices, responsive 320px-1024px
4. **Chess Casino Aesthetic**: Professional gambling UI with chess theme integration
5. **Full Accessibility**: WCAG 2.1 AA compliance, screen readers, reduce motion support

### Implementation Code

**components/casino/slots/EnhancedSlotMachine.tsx**:
```typescript
// Mobile-optimized slot machine from research
const EnhancedSlotMachine: React.FC<SlotMachineProps> = ({ coinBalance, setCoinBalance }) => {
  const { spin, isSpinning, reels, winResult } = useSlotMachine()
  const { playSound } = useCasinoAudio()
  const { vibrate } = useHapticFeedback()
  const springProps = useSlotAnimations(isSpinning, reels)
  
  // Touch-friendly bet controls from research
  const handleBetAdjust = useCallback((delta: number) => {
    const newWager = Math.max(1, Math.min(100, wager + delta))
    setWager(newWager)
    vibrate('spin') // Haptic feedback for adjustment
  }, [wager])
  
  // Research: 500ms hold-to-repeat functionality 
  const { isHolding, startHold, stopHold } = useHoldToRepeat(handleBetAdjust, 500)
  
  return (
    <div className="slot-machine" style={{
      // Safe area handling for notched devices
      paddingTop: 'env(safe-area-inset-top)',
      paddingBottom: 'env(safe-area-inset-bottom)',
    }}>
      {/* Reels with hardware acceleration */}
      <div className="reels-container">
        {reels.map((symbol, index) => (
          <SlotReel
            key={index}
            symbol={symbol}
            isSpinning={isSpinning}
            delay={REEL_STOP_DELAYS[index]} // 0, 200, 400ms stagger
            style={{
              willChange: 'transform', // GPU acceleration
              ...springProps[index]
            }}
          />
        ))}
      </div>
      
      {/* Touch-optimized controls */}
      <div className="bet-controls">
        <TouchButton
          size="large" // 60x60px from research
          onMouseDown={() => startHold(-1)}
          onMouseUp={stopHold}
          onTouchStart={() => startHold(-1)}
          onTouchEnd={stopHold}
          disabled={wager <= 1}
          hapticFeedback="spin"
        >
          <Minus className="w-6 h-6" />
        </TouchButton>
        
        <CoinDisplay amount={wager} />
        
        <TouchButton
          size="large"
          onMouseDown={() => startHold(1)}
          onMouseUp={stopHold}
          onTouchStart={() => startHold(1)}
          onTouchEnd={stopHold}
          disabled={wager >= 100}
          hapticFeedback="spin"
        >
          <Plus className="w-6 h-6" />
        </TouchButton>
      </div>
      
      {/* Accessible spin button */}
      <SpinButton
        onClick={spin}
        disabled={isSpinning || coinBalance < wager}
        isSpinning={isSpinning}
        aria-label={`Spin reels for ${wager} coins`}
        style={{
          minHeight: '60px', // Touch target size
          minWidth: '120px',
        }}
      />
    </div>
  )
}
```

**components/casino/slots/SlotReel.tsx**:
```typescript
// Individual reel with React Spring physics
const SlotReel: React.FC<SlotReelProps> = ({ symbol, isSpinning, delay }) => {
  const springProps = useSpring({
    transform: isSpinning 
      ? 'translateY(-2000px)' // Research: 2000px spin distance
      : 'translateY(0px)',
    config: {
      tension: 120, // Spring physics for realistic deceleration
      friction: 14,
    },
    delay: delay, // Staggered stopping
  })
  
  return (
    <animated.div 
      className="slot-reel"
      style={{
        ...springProps,
        willChange: 'transform', // Hardware acceleration hint
      }}
    >
      <div className="symbol" style={{
        fontSize: '3rem', // Large enough for mobile
        textShadow: '0 2px 4px rgba(0, 0, 0, 0.3)', // Readability
      }}>
        {symbol}
      </div>
    </animated.div>
  )
}
```

**components/casino/slots/BetControls.tsx**:
```typescript
// Research-based betting interface
const BetControls: React.FC = () => {
  // Prevent accidental max bets (research finding)
  const handleMaxBet = () => {
    const maxBetThreshold = coinBalance * 0.5 // 50% of balance
    if (wager > maxBetThreshold) {
      // Confirmation modal for large bets
      setShowConfirmation(true)
    } else {
      setWager(Math.min(100, coinBalance))
    }
  }
  
  return (
    <div className="bet-controls-grid">
      {/* Research: Visual feedback on all touches */}
      <TouchButton 
        variant="decrease"
        disabled={wager <= 1}
        onPress={() => {
          vibrate('spin')
          handleBetAdjust(-1)
        }}
        style={{
          minWidth: '44px', // iOS HIG minimum
          minHeight: '44px',
        }}
      >
        <Minus />
      </TouchButton>
      
      {/* Research: Clear wager display with coin icon */}
      <div className="wager-display">
        <Coins className="w-5 h-5 text-accent" />
        <span className="text-2xl font-bold">{wager}</span>
      </div>
      
      <TouchButton 
        variant="increase"
        disabled={wager >= 100 || wager >= coinBalance}
        onPress={() => {
          vibrate('spin')
          handleBetAdjust(1)
        }}
      >
        <Plus />
      </TouchButton>
    </div>
  )
}
```

## Phase 6: Casino Index Page (Priority 6 - High)

### Overview
Enhanced state management with comprehensive balance tracking, transaction logging, and persistence.

### Files to Create
- `src/stores/casinoStore.ts`
- `src/services/casino/BalanceService.ts`
- `src/services/casino/TransactionLogger.ts`
- `src/utils/casino/storage.utils.ts`
- `src/hooks/casino/useCasinoBalance.ts`
- `src/hooks/casino/useGameSession.ts`
- `src/types/casino/transaction.types.ts`

### Files to Modify
- `src/stores/appStore.ts` (integrate casino store)
- `src/types/casino/index.ts` (add transaction types)
- `src/hooks/casino/index.ts` (add balance hooks)

### Integration Points
- Zustand persistence middleware
- IndexedDB/localStorage APIs
- All casino components (for balance updates)

### Key Deliverables
1. **Zustand Casino Store**: Persistent store with `partialize` for selective localStorage sync
2. **Atomic Balance Updates**: Functional updates `setBalance(prev => prev - wager)` preventing race conditions
3. **IndexedDB Transactions**: Structured logging with Dexie.js, schema: `{gameType, timestamp, bet, winAmount, balance}`
4. **Session Persistence**: `beforeunload` + `visibilitychange` handlers for state backup
5. **Balance Validation**: Prevent negative balances, insufficient funds graceful handling

### Implementation Code

**stores/casinoStore.ts**:
```typescript
// Research-optimized Zustand store
interface CasinoState {
  // Game state
  coinBalance: number
  currentGame: 'slots' | 'blackjack' | 'poker' | null
  gameSession: GameSession
  
  // Transaction tracking
  transactionHistory: Transaction[]
  sessionStats: SessionStats
  
  // UI state
  isGameActive: boolean
  lastWinAmount: number
}

interface CasinoActions {
  // Atomic balance operations from research
  placeBet: (amount: number) => boolean // Returns false if insufficient funds
  addWinnings: (amount: number) => void
  resetBalance: () => void
  
  // Transaction logging
  logTransaction: (transaction: Transaction) => void
  getGameHistory: (gameType: string) => Transaction[]
  
  // Session management
  startGameSession: (gameType: string) => void
  endGameSession: () => void
}

export const useCasinoStore = create<CasinoState & CasinoActions>()(
  subscribeWithSelector(
    persist(
      (set, get) => ({
        // Initial state
        coinBalance: 1000, // Starting balance
        currentGame: null,
        gameSession: null,
        transactionHistory: [],
        sessionStats: { totalWagered: 0, totalWon: 0, sessionsPlayed: 0 },
        isGameActive: false,
        lastWinAmount: 0,
        
        // Research: Atomic balance operations prevent race conditions
        placeBet: (amount: number) => {
          const { coinBalance } = get()
          if (coinBalance < amount) {
            // Research: Graceful insufficient funds handling
            return false
          }
          
          set((state) => ({ 
            coinBalance: state.coinBalance - amount,
            // Log transaction immediately
            transactionHistory: [
              ...state.transactionHistory,
              {
                id: crypto.randomUUID(),
                gameType: state.currentGame!,
                type: 'bet',
                amount: -amount,
                balance: state.coinBalance - amount,
                timestamp: Date.now()
              }
            ]
          }))
          
          return true
        },
        
        addWinnings: (amount: number) => {
          set((state) => ({
            coinBalance: state.coinBalance + amount,
            lastWinAmount: amount,
            transactionHistory: [
              ...state.transactionHistory,
              {
                id: crypto.randomUUID(), 
                gameType: state.currentGame!,
                type: 'win',
                amount: amount,
                balance: state.coinBalance + amount,
                timestamp: Date.now()
              }
            ]
          }))
        },
        
        // Research: Session tracking for analytics
        startGameSession: (gameType: string) => {
          set({
            currentGame: gameType as any,
            isGameActive: true,
            gameSession: {
              id: crypto.randomUUID(),
              gameType,
              startTime: Date.now(),
              startBalance: get().coinBalance
            }
          })
        },
        
        endGameSession: () => {
          const { gameSession, coinBalance } = get()
          if (gameSession) {
            // Log session completion
            set((state) => ({
              sessionStats: {
                ...state.sessionStats,
                sessionsPlayed: state.sessionStats.sessionsPlayed + 1
              },
              isGameActive: false,
              currentGame: null,
              gameSession: null
            }))
          }
        }
      }),
      {
        name: 'casino-store',
        // Research: Selective persistence to optimize localStorage
        partialize: (state) => ({
          coinBalance: state.coinBalance,
          transactionHistory: state.transactionHistory.slice(-100), // Keep last 100
          sessionStats: state.sessionStats,
        }),
        onRehydrateStorage: () => (state) => {
          // Restore game session on reload
          if (state?.gameSession) {
            state.isGameActive = true
          }
        }
      }
    )
  )
)
```

**services/casino/BalanceService.ts**:
```typescript
// Research-based balance validation service
class BalanceService {
  // Prevent race conditions with functional updates
  static validateBet(balance: number, wager: number): ValidationResult {
    if (balance < wager) {
      return {
        isValid: false,
        error: 'Insufficient balance',
        suggestedAction: 'reduce-bet',
        maxBet: balance
      }
    }
    
    // Research: Warn on large bets (>50% balance)
    if (wager > balance * 0.5) {
      return {
        isValid: true,
        warning: 'Large bet detected',
        requiresConfirmation: true
      }
    }
    
    return { isValid: true }
  }
  
  // Format currency with commas (research requirement)
  static formatCoins(amount: number): string {
    return new Intl.NumberFormat('en-US').format(amount)
  }
}
```

**hooks/casino/useCasinoBalance.ts**:
```typescript
// Research-optimized balance hook
const useCasinoBalance = () => {
  const balance = useCasinoStore(state => state.coinBalance)
  const placeBet = useCasinoStore(state => state.placeBet)
  const addWinnings = useCasinoStore(state => state.addWinnings)
  
  // Research: Debounced balance updates for rapid interactions
  const debouncedBalance = useDebounce(balance, 100)
  
  const handleBet = useCallback((amount: number) => {
    const success = placeBet(amount)
    if (!success) {
      // Research: User feedback for insufficient funds
      toast.error('Insufficient coins! Bet reduced to maximum available.')
      return false
    }
    return true
  }, [placeBet])
  
  return {
    balance: debouncedBalance,
    formattedBalance: BalanceService.formatCoins(balance),
    handleBet,
    addWinnings,
    canAfford: (amount: number) => balance >= amount
  }
}
```

## Phase 7: Mobile Optimization (Priority 7 - Medium)

### Overview
Mobile-specific optimizations for touch interactions, performance, and battery efficiency.

### Files to Create
- `src/hooks/casino/useTouchGestures.ts`
- `src/hooks/casino/usePerformanceMonitoring.ts`
- `src/utils/casino/mobile-detection.utils.ts`
- `src/utils/casino/performance.utils.ts`
- `src/services/casino/PerformanceService.ts`
- `src/components/casino/shared/TouchFeedback.tsx`

### Files to Modify
- All casino components (add mobile optimizations)
- `src/hooks/casino/index.ts` (add mobile hooks)
- `src/utils/casino/index.ts` (add mobile utils)

### Integration Points
- All existing casino components
- Performance Observer API
- Battery API (when available)
- Screen Wake Lock API

### Key Deliverables
1. **Touch Gestures**: Tap primary actions, long-press (500ms+) for rapid bet adjust, 44px minimum targets
2. **Performance Tracking**: `performance.now()` frame timing, FPS counter, <16ms React render target
3. **Battery Optimization**: Pause animations when `visibilityState === 'hidden'`, reduce complexity on low battery
4. **Responsive Design**: CSS Grid `minmax()`, 320px-1024px viewport support, orientation handling
5. **Mobile Accessibility**: Screen reader support, high contrast mode, reduce motion preferences

### Implementation Code

**hooks/casino/useTouchGestures.ts**:
```typescript
// Research-based touch interaction patterns
const useTouchGestures = () => {
  const [isLongPressing, setIsLongPressing] = useState(false)
  const longPressTimer = useRef<number>()
  
  // Research: 500ms+ long press for rapid bet adjustment
  const handleTouchStart = useCallback((action: () => void) => {
    longPressTimer.current = window.setTimeout(() => {
      setIsLongPressing(true)
      // Start rapid repeat every 100ms
      const interval = setInterval(action, 100)
      
      const cleanup = () => {
        clearInterval(interval)
        setIsLongPressing(false)
      }
      
      // Research: Clean up on touch end
      const handleTouchEnd = () => {
        cleanup()
        document.removeEventListener('touchend', handleTouchEnd)
      }
      
      document.addEventListener('touchend', handleTouchEnd)
    }, 500) // Research: 500ms threshold
  }, [])
  
  const handleTouchEnd = useCallback(() => {
    if (longPressTimer.current) {
      clearTimeout(longPressTimer.current)
    }
  }, [])
  
  return { handleTouchStart, handleTouchEnd, isLongPressing }
}
```

**hooks/casino/usePerformanceMonitoring.ts**:
```typescript
// Research: Performance monitoring for 60fps target
const usePerformanceMonitoring = () => {
  const [performanceMetrics, setPerformanceMetrics] = useState({
    fps: 60,
    frameTime: 16.67,
    memoryUsage: 0,
    isLowPerformance: false
  })
  
  useEffect(() => {
    let lastTime = performance.now()
    let frameCount = 0
    
    const measurePerformance = () => {
      const now = performance.now()
      const frameTime = now - lastTime
      frameCount++
      
      // Calculate FPS every 60 frames
      if (frameCount >= 60) {
        const fps = 1000 / (frameTime / frameCount)
        
        setPerformanceMetrics(prev => ({
          ...prev,
          fps: Math.round(fps),
          frameTime: frameTime / frameCount,
          isLowPerformance: fps < 45 // Research: Below 45fps = low performance
        }))
        
        frameCount = 0
      }
      
      lastTime = now
      requestAnimationFrame(measurePerformance)
    }
    
    requestAnimationFrame(measurePerformance)
    
    // Memory monitoring
    if ('memory' in performance) {
      const updateMemory = () => {
        const memory = (performance as any).memory
        setPerformanceMetrics(prev => ({
          ...prev,
          memoryUsage: Math.round(memory.usedJSHeapSize / 1024 / 1024) // MB
        }))
      }
      
      const interval = setInterval(updateMemory, 5000) // Every 5s
      return () => clearInterval(interval)
    }
  }, [])
  
  return performanceMetrics
}
```

**utils/casino/mobile-detection.utils.ts**:
```typescript
// Research: Device capability detection
export const MobileDetection = {
  // Detect device performance tier
  getPerformanceTier(): 'low' | 'medium' | 'high' {
    const cores = navigator.hardwareConcurrency || 2
    const memory = (navigator as any).deviceMemory || 2
    
    // Research-based performance tiers
    if (cores >= 8 && memory >= 4) return 'high'
    if (cores >= 4 && memory >= 2) return 'medium'
    return 'low'
  },
  
  // Battery level detection for optimization
  async getBatteryInfo() {
    if ('getBattery' in navigator) {
      const battery = await (navigator as any).getBattery()
      return {
        level: battery.level,
        charging: battery.charging,
        isLowBattery: battery.level < 0.2 // Below 20%
      }
    }
    return null
  },
  
  // Network quality detection
  getNetworkQuality(): 'slow' | 'fast' | 'unknown' {
    const connection = (navigator as any).connection
    if (!connection) return 'unknown'
    
    // Research: Optimize for slow connections
    const slowTypes = ['slow-2g', '2g', '3g']
    return slowTypes.includes(connection.effectiveType) ? 'slow' : 'fast'
  }
}
```

**components/casino/shared/TouchFeedback.tsx**:
```typescript
// Research: 16ms touch response target
const TouchFeedback: React.FC<TouchFeedbackProps> = ({ 
  children, 
  onPress, 
  hapticType = 'spin',
  minSize = 44 // Research: 44px minimum for accessibility
}) => {
  const [isPressed, setIsPressed] = useState(false)
  const { vibrate } = useHapticFeedback()
  
  // Research: Sub-16ms visual feedback
  const pressStyle = useSpring({
    scale: isPressed ? 0.95 : 1.0,
    backgroundColor: isPressed ? 'rgba(34, 197, 94, 0.8)' : 'rgba(34, 197, 94, 1)',
    config: { tension: 300, friction: 10 }, // Fast response
  })
  
  const handlePressStart = useCallback(() => {
    setIsPressed(true)
    vibrate(hapticType) // Immediate haptic feedback
  }, [vibrate, hapticType])
  
  const handlePressEnd = useCallback(() => {
    setIsPressed(false)
    onPress?.()
  }, [onPress])
  
  return (
    <animated.button
      style={{
        ...pressStyle,
        minWidth: `${minSize}px`,
        minHeight: `${minSize}px`,
        touchAction: 'manipulation', // Prevent zoom
      }}
      onTouchStart={handlePressStart}
      onTouchEnd={handlePressEnd}
      onMouseDown={handlePressStart}
      onMouseUp={handlePressEnd}
    >
      {children}
    </animated.button>
  )
}
```

## Phase 9: Blackjack Game (Priority 9 - Medium)

### Overview
Complete single-player blackjack game implementation with mobile-optimized UI.

### Files to Create
- `src/pages/casino/BlackjackPage.tsx`
- `src/components/casino/blackjack/BlackjackGame.tsx`
- `src/components/casino/blackjack/Card.tsx`
- `src/components/casino/blackjack/Hand.tsx`
- `src/components/casino/blackjack/DealerArea.tsx`
- `src/components/casino/blackjack/PlayerArea.tsx`
- `src/components/casino/blackjack/ActionButtons.tsx`
- `src/services/casino/BlackjackLogic.ts`
- `src/services/casino/CardDeckService.ts`
- `src/hooks/casino/useBlackjack.ts`
- `src/types/casino/blackjack.types.ts`
- `src/constants/casino/blackjack-rules.constants.ts`
- `src/utils/casino/card-game.utils.ts`

### Files to Modify
- `src/pages/index.ts` (add BlackjackPage export)
- `src/App.tsx` (add blackjack routing)
- `src/types/casino/index.ts` (add blackjack types)

### Integration Points
- `src/stores/casinoStore.ts` (from Phase 6)
- `src/hooks/casino/useCasinoAudio.ts` (from Phase 4)
- `src/hooks/casino/useCasinoBalance.ts` (from Phase 6)

### Key Deliverables
1. **Simplified Blackjack**: Basic hit/stand/double rules, single deck, dealer stands soft 17, 3:2 blackjack payout
2. **Touch Card System**: Swipe up=hit, swipe down=stand, tap=select, 80x120px minimum card size
3. **Dealer AI**: Simple deterministic rules with 1-2s "thinking" delay, shuffle at 75% deck penetration
4. **Mobile Interface**: Bottom action bar with 60x60px buttons, card fan layout with 15Â° rotation
5. **Visual Design**: High contrast card indices, oversized numbers, vertical stack for portrait mode

## Phase 10: Texas Hold'em Game (Priority 10 - Medium)

### Overview
Complete single-player Texas Hold'em poker implementation following domain-driven design principles with AI opponents, betting rounds, and mobile-optimized UI.

### Domain Models and Entities
Following DDD patterns from the architecture guide, we establish clear domain boundaries and entities:

#### Core Domain Entities
- **Player Entity**: Represents player with unique ID, chip stack, position, and betting history
- **AIOpponent Entity**: AI player with difficulty level, playing style, and decision-making algorithms  
- **PokerTable Entity**: Game state aggregate root managing blinds, pot, community cards, and player actions
- **Hand Entity**: Individual poker hand with cards and strength evaluation
- **BettingRound Entity**: Manages preflop, flop, turn, river betting sequences

#### Value Objects
- **PokerCard**: Suit, rank, and display representation (immutable)
- **ChipStack**: Validates minimum bets, prevents negative balances
- **Position**: Dealer, small blind, big blind, early/late position logic
- **HandStrength**: Royal flush through high card with tie-breaker rules
- **BetAction**: Fold, call, raise amounts with validation rules

### Files to Create

#### Domain Layer (Business Logic)
- `src/services/casino/holdem/HoldemGameService.ts` - Core game rules and state management
- `src/services/casino/holdem/HandEvaluatorService.ts` - Poker hand ranking and comparison
- `src/services/casino/holdem/BettingService.ts` - Betting round logic and pot management
- `src/services/casino/holdem/AIPlayerService.ts` - Computer opponent decision making
- `src/services/casino/holdem/DealerService.ts` - Card dealing and shuffling logic

#### Types and Value Objects
- `src/types/casino/holdem.types.ts` - All Texas Hold'em domain types
- `src/types/casino/poker-common.types.ts` - Shared poker types (cards, hands)
- `src/utils/casino/holdem/hand-evaluation.utils.ts` - Pure hand comparison functions
- `src/utils/casino/holdem/betting-validation.utils.ts` - Bet size and action validation
- `src/utils/casino/holdem/ai-strategy.utils.ts` - AI decision-making algorithms

#### Constants and Configuration
- `src/constants/casino/holdem/game-rules.constants.ts` - Blinds, betting limits, hand rankings
- `src/constants/casino/holdem/ai-personalities.constants.ts` - Different AI opponent types
- `src/constants/casino/holdem/betting-patterns.constants.ts` - Predefined betting scenarios

#### Application Services (Hooks)
- `src/hooks/casino/useHoldem.ts` - Main game state management hook
- `src/hooks/casino/useHoldemAI.ts` - AI opponent management
- `src/hooks/casino/useHoldemBetting.ts` - Betting interface and validation
- `src/hooks/casino/useHandAnimation.ts` - Card dealing and reveal animations

#### Presentation Layer (Components)
- `src/pages/casino/HoldemPage.tsx` - Main Texas Hold'em page component
- `src/components/casino/holdem/HoldemTable.tsx` - Main game table layout
- `src/components/casino/holdem/CommunityCards.tsx` - Flop, turn, river display
- `src/components/casino/holdem/PlayerPosition.tsx` - Individual player area with chips/cards
- `src/components/casino/holdem/BettingControls.tsx` - Mobile-optimized betting interface
- `src/components/casino/holdem/PotDisplay.tsx` - Current pot amount with side pots
- `src/components/casino/holdem/HandStrengthMeter.tsx` - Visual hand strength indicator
- `src/components/casino/holdem/ActionHistory.tsx` - Recent betting actions log
- `src/components/casino/holdem/WinnerCelebration.tsx` - Hand winner announcement

### Files to Modify
- `src/pages/index.ts` (add HoldemPage export)
- `src/App.tsx` (add holdem routing)
- `src/types/casino/index.ts` (add holdem types export)
- `src/stores/casinoStore.ts` (add holdem game state)

### Integration Points
- `src/services/casino/CasinoRNGService.ts` - Card shuffling and dealing
- `src/stores/casinoStore.ts` - Balance management and game history
- `src/hooks/casino/useCasinoAudio.ts` - Card dealing sounds and chip sounds
- `src/components/casino/shared/TouchFeedback.tsx` - Betting button interactions

### Key Deliverables

#### 1. Domain-Driven Architecture
Following the architecture guide's DDD principles:
- **Domain Services**: `HoldemGameService` manages game rules, `AIPlayerService` handles computer opponents
- **Repository Pattern**: Game state persistence and hand history tracking
- **Value Objects**: Immutable `PokerCard`, `ChipStack`, and `HandStrength` objects
- **Entities**: `Player`, `PokerTable`, and `BettingRound` with clear boundaries

#### 2. Texas Hold'em Game Logic
- **Complete Rules**: Blinds structure, betting rounds (preflop/flop/turn/river), all-in scenarios
- **Hand Evaluation**: Standard poker rankings with proper tie-breaker logic (kickers, side pots)
- **AI Opponents**: 3 difficulty levels (Tight/Aggressive/Loose) with realistic betting patterns
- **Position Awareness**: Button rotation, blind posting, action order enforcement

#### 3. Mobile-Optimized Interface
- **Touch Betting**: Slider for bet sizing, quick bet buttons (min/1/2 pot/all-in), 60x60px targets
- **Card Visibility**: Large community cards (80x120px), hole cards with peek functionality
- **Action Indicators**: Clear visual feedback for fold/call/raise, turn indicators, pot odds display
- **Portrait Layout**: Vertical table design optimized for mobile screens

#### 4. Advanced Features
- **Side Pots**: Proper all-in handling with multiple players and side pot calculations
- **Betting Validation**: Minimum raise rules, string bet prevention, proper all-in logic
- **Hand Strength**: Real-time evaluation showing current hand strength and potential draws
- **Game Statistics**: Win rate tracking, showdown analytics, betting pattern analysis

### Implementation Code

**services/casino/holdem/HoldemGameService.ts**:
```typescript
// Domain service following DDD principles
export class HoldemGameService {
  private readonly handEvaluator: HandEvaluatorService
  private readonly bettingService: BettingService
  private readonly dealerService: DealerService

  constructor(
    handEvaluator: HandEvaluatorService,
    bettingService: BettingService, 
    dealerService: DealerService
  ) {
    this.handEvaluator = handEvaluator
    this.bettingService = bettingService
    this.dealerService = dealerService
  }

  // Core domain operation - start new hand
  public startNewHand(tableState: PokerTable): HoldemGameState {
    // Validate minimum players (2-6 for heads-up to 6-max)
    if (tableState.activePlayers.length < 2) {
      throw new HoldemGameError('Insufficient players for hand')
    }

    // Post blinds following proper blind structure
    const gameState = this.bettingService.postBlinds(tableState)
    
    // Deal hole cards (2 to each player)
    const dealtState = this.dealerService.dealHoleCards(gameState)
    
    // Initialize preflop betting round
    return this.bettingService.initializeBettingRound(dealtState, 'preflop')
  }

  // Domain operation - process player action
  public processPlayerAction(
    gameState: HoldemGameState, 
    playerId: string, 
    action: BetAction
  ): HoldemActionResult {
    // Validate action is legal for current game state
    const validation = this.bettingService.validateAction(gameState, playerId, action)
    if (!validation.isValid) {
      return { success: false, error: validation.error, gameState }
    }

    // Execute the action and update game state
    const updatedState = this.bettingService.executeAction(gameState, playerId, action)
    
    // Check if betting round is complete
    if (this.bettingService.isBettingRoundComplete(updatedState)) {
      return this.advanceToNextStreet(updatedState)
    }

    return { success: true, gameState: updatedState }
  }

  // Private domain logic - advance game to next street
  private advanceToNextStreet(gameState: HoldemGameState): HoldemActionResult {
    const nextStreet = this.getNextStreet(gameState.currentStreet)
    
    if (nextStreet === 'showdown') {
      return this.processShowdown(gameState)
    }

    // Deal community cards based on street
    const cardsToDeal = this.getCommunityCardsForStreet(nextStreet)
    const updatedState = this.dealerService.dealCommunityCards(gameState, cardsToDetail)
    
    // Start new betting round
    const newBettingState = this.bettingService.initializeBettingRound(updatedState, nextStreet)
    
    return { success: true, gameState: newBettingState }
  }

  // Domain operation - determine hand winner
  private processShowdown(gameState: HoldemGameState): HoldemActionResult {
    const activePlayers = gameState.players.filter(p => !p.hasFolded)
    const handResults = activePlayers.map(player => ({
      playerId: player.id,
      handStrength: this.handEvaluator.evaluateHand(
        player.holeCards, 
        gameState.communityCards
      )
    }))

    // Handle side pots for all-in scenarios
    const winners = this.bettingService.determineWinners(handResults, gameState.sidePots)
    const finalState = this.bettingService.distributePots(gameState, winners)

    return { 
      success: true, 
      gameState: finalState,
      showdown: { winners, handResults }
    }
  }
}
```

**services/casino/holdem/AIPlayerService.ts**:
```typescript
// AI opponent service with personality-based decision making
export class AIPlayerService {
  private readonly gameService: HoldemGameService
  private readonly personalities: Map<string, AIPersonality>

  // AI decision making based on hand strength and position
  public makeDecision(
    gameState: HoldemGameState, 
    aiPlayerId: string
  ): Promise<BetAction> {
    const player = gameState.players.find(p => p.id === aiPlayerId)
    const personality = this.personalities.get(player.personalityType)
    
    // Calculate hand strength (0-1 scale)
    const handStrength = this.evaluateHandStrength(
      player.holeCards,
      gameState.communityCards
    )

    // Consider position (early/late position affects aggression)
    const positionFactor = this.getPositionFactor(player.position, gameState.buttonPosition)
    
    // Analyze betting action and pot odds
    const potOdds = this.calculatePotOdds(gameState)
    const bettingPressure = this.analyzeBettingPressure(gameState)

    // Make decision based on personality and game theory
    return this.decideAction(handStrength, positionFactor, potOdds, personality)
  }

  private decideAction(
    handStrength: number,
    positionFactor: number,
    potOdds: number,
    personality: AIPersonality
  ): BetAction {
    // Tight-aggressive personality (plays few hands, bets strong)
    if (personality.type === 'tight-aggressive') {
      if (handStrength > 0.8) {
        return { type: 'raise', amount: this.calculateRaiseSize(handStrength, 'aggressive') }
      }
      if (handStrength > 0.6 && positionFactor > 0.5) {
        return { type: 'call' }
      }
      return { type: 'fold' }
    }

    // Loose-aggressive personality (plays many hands, bets frequently)
    if (personality.type === 'loose-aggressive') {
      if (handStrength > 0.4 || positionFactor > 0.7) {
        const shouldRaise = Math.random() < personality.aggressionLevel
        return shouldRaise 
          ? { type: 'raise', amount: this.calculateRaiseSize(handStrength, 'loose') }
          : { type: 'call' }
      }
      return handStrength > 0.2 ? { type: 'call' } : { type: 'fold' }
    }

    // Conservative personality (calls frequently, rarely raises)
    return this.makeConservativeDecision(handStrength, potOdds)
  }
}
```

**hooks/casino/useHoldem.ts**:
```typescript
// Main application service hook following architecture patterns
export const useHoldem = (): HoldemGameHook => {
  const { balance, placeBet, addWinnings } = useCasinoBalance()
  const { playSound } = useCasinoAudio()
  const gameServiceRef = useRef(new HoldemGameService(
    new HandEvaluatorService(),
    new BettingService(),
    new DealerService()
  ))

  const [gameState, setGameState] = useState<HoldemGameState | null>(null)
  const [isProcessingAction, setIsProcessingAction] = useState(false)

  // Initialize new game following domain rules
  const startNewGame = useCallback(async (buyInAmount: number): Promise<boolean> => {
    if (!balance.canAfford(buyInAmount)) {
      toast.error('Insufficient balance for buy-in')
      return false
    }

    // Use domain service to create initial game state
    const initialState = gameServiceRef.current.initializeGame({
      buyInAmount,
      blindStructure: HOLDEM_BLINDS,
      maxPlayers: 6,
      playerPosition: 'button' // Start player as dealer
    })

    setGameState(initialState)
    
    // Place buy-in bet
    const success = placeBet(buyInAmount)
    if (success) {
      playSound('chipStack')
      return true
    }
    
    return false
  }, [balance, placeBet, playSound])

  // Process player action through domain service
  const makeAction = useCallback(async (action: BetAction): Promise<boolean> => {
    if (!gameState || isProcessingAction) return false
    
    setIsProcessingAction(true)
    
    try {
      // Validate bet amount against balance
      if (action.type === 'raise' && !balance.canAfford(action.amount)) {
        toast.error('Insufficient chips for bet')
        return false
      }

      // Execute action through domain service
      const result = gameServiceRef.current.processPlayerAction(
        gameState, 
        gameState.humanPlayerId, 
        action
      )

      if (result.success) {
        setGameState(result.gameState)
        
        // Handle different action types
        switch (action.type) {
          case 'raise':
            placeBet(action.amount)
            playSound('chipBet')
            break
          case 'call':
            placeBet(gameState.callAmount)
            playSound('chipCall')
            break
          case 'fold':
            playSound('cardFold')
            break
        }

        // Process AI actions after player
        if (result.gameState.currentPlayer !== gameState.humanPlayerId) {
          setTimeout(() => processAIActions(result.gameState), 1000)
        }

        return true
      } else {
        toast.error(result.error)
        return false
      }
    } catch (error) {
      toast.error('Action failed')
      return false
    } finally {
      setIsProcessingAction(false)
    }
  }, [gameState, isProcessingAction, balance, placeBet, playSound])

  // Handle AI opponent actions
  const processAIActions = useCallback(async (currentState: HoldemGameState) => {
    let state = currentState
    const aiService = new AIPlayerService()
    
    // Process all AI players in turn order
    while (state.currentPlayer !== state.humanPlayerId && !state.isHandComplete) {
      const currentPlayer = state.players.find(p => p.id === state.currentPlayer)
      if (currentPlayer?.isAI) {
        // Add realistic thinking delay
        await new Promise(resolve => setTimeout(resolve, 1500 + Math.random() * 1000))
        
        const aiAction = await aiService.makeDecision(state, currentPlayer.id)
        const result = gameServiceRef.current.processPlayerAction(state, currentPlayer.id, aiAction)
        
        if (result.success) {
          state = result.gameState
          setGameState(state)
          
          // Play appropriate sound for AI action
          switch (aiAction.type) {
            case 'raise': playSound('chipBet'); break
            case 'call': playSound('chipCall'); break
            case 'fold': playSound('cardFold'); break
          }
        }
      }
    }

    // Handle hand completion
    if (state.isHandComplete && state.winners) {
      const playerWinnings = state.winners
        .filter(w => w.playerId === state.humanPlayerId)
        .reduce((sum, w) => sum + w.amount, 0)
      
      if (playerWinnings > 0) {
        addWinnings(playerWinnings)
        playSound('winBig')
      }
    }
  }, [playSound, addWinnings])

  return {
    gameState,
    isProcessingAction,
    startNewGame,
    makeAction,
    // Derived state
    canCheck: gameState?.callAmount === 0,
    canCall: gameState?.callAmount > 0,
    canRaise: gameState && balance.canAfford(gameState.minimumRaise),
    potOdds: gameState ? calculatePotOdds(gameState) : 0,
    handStrength: gameState ? evaluatePlayerHandStrength(gameState) : 0
  }
}
```

## Phase 11: Roulette Game (Priority 11 - Medium)

### Overview
Complete American and European roulette implementation following domain-driven design principles with physics-based wheel animation, comprehensive betting options, and mobile-optimized betting table.

### Domain Models and Entities
Following DDD patterns from the architecture guide with clear separation of concerns:

#### Core Domain Entities
- **RouletteWheel Entity**: Manages wheel state, ball position, number selection, and spin physics
- **BettingTable Entity**: Aggregate root for all betting positions, odds, and payout calculations
- **RouletteBet Entity**: Individual bet with type, position, amount, and payout multiplier
- **SpinResult Entity**: Winning number, color, and associated winning/losing bet determination
- **GameSession Entity**: Tracks betting history, statistics, and session management

#### Value Objects  
- **RouletteNumber**: Number (0-36), color (red/black/green), position, adjacent numbers
- **BetType**: Inside bets (straight, split, street, corner) and outside bets (red/black, odd/even)
- **WheelPosition**: Physics position with velocity, acceleration, and final resting position
- **PayoutRatio**: Immutable payout multipliers for different bet types (35:1 straight, 1:1 red/black)
- **BetValidation**: Validates bet amounts, table limits, and conflicting bets

### Files to Create

#### Domain Layer (Business Logic)
- `src/services/casino/roulette/RouletteGameService.ts` - Core game rules and spin logic
- `src/services/casino/roulette/WheelPhysicsService.ts` - Ball physics and realistic spin simulation
- `src/services/casino/roulette/BettingTableService.ts` - Bet placement, validation, and payout calculation
- `src/services/casino/roulette/PayoutCalculatorService.ts` - Winning determination and payout processing
- `src/services/casino/roulette/RouletteHistoryService.ts` - Number history and trend analysis

#### Types and Value Objects
- `src/types/casino/roulette.types.ts` - All roulette domain types and interfaces
- `src/utils/casino/roulette/bet-validation.utils.ts` - Bet placement and limit validation
- `src/utils/casino/roulette/wheel-physics.utils.ts` - Physics calculations and animations
- `src/utils/casino/roulette/payout-calculation.utils.ts` - Winning bet determination logic
- `src/utils/casino/roulette/number-analysis.utils.ts` - Hot/cold number tracking and statistics

#### Constants and Configuration
- `src/constants/casino/roulette/wheel-layout.constants.ts` - American/European wheel layouts
- `src/constants/casino/roulette/bet-types.constants.ts` - All bet types with payouts and positions
- `src/constants/casino/roulette/table-limits.constants.ts` - Minimum/maximum bet limits per bet type
- `src/constants/casino/roulette/physics-config.constants.ts` - Wheel spin physics parameters

#### Application Services (Hooks)
- `src/hooks/casino/useRoulette.ts` - Main game state management hook
- `src/hooks/casino/useRouletteBetting.ts` - Bet placement and validation logic
- `src/hooks/casino/useWheelAnimation.ts` - Wheel and ball animation control
- `src/hooks/casino/useRouletteHistory.ts` - Number history and statistics tracking

#### Presentation Layer (Components)
- `src/pages/casino/RoulettePage.tsx` - Main roulette page component
- `src/components/casino/roulette/RouletteTable.tsx` - Complete roulette table layout
- `src/components/casino/roulette/RouletteWheel.tsx` - Animated wheel with physics simulation
- `src/components/casino/roulette/BettingBoard.tsx` - Interactive betting table with touch zones
- `src/components/casino/roulette/NumberHistory.tsx` - Recent winning numbers display
- `src/components/casino/roulette/BetChips.tsx` - Draggable betting chips with denominations
- `src/components/casino/roulette/PayoutDisplay.tsx` - Winning announcements and payout amounts
- `src/components/casino/roulette/StatisticsPanel.tsx` - Hot/cold numbers and betting trends

### Files to Modify
- `src/pages/index.ts` (add RoulettePage export)
- `src/App.tsx` (add roulette routing)
- `src/types/casino/index.ts` (add roulette types export)
- `src/stores/casinoStore.ts` (add roulette game state)

### Integration Points
- `src/services/casino/CasinoRNGService.ts` - Physics-based random number generation
- `src/stores/casinoStore.ts` - Balance management and betting history
- `src/hooks/casino/useCasinoAudio.ts` - Wheel spinning and ball drop sounds
- `src/components/casino/shared/TouchFeedback.tsx` - Bet placement interactions

### Key Deliverables

#### 1. Domain-Driven Architecture
Following the architecture guide's DDD principles:
- **Domain Services**: `RouletteGameService` manages game flow, `WheelPhysicsService` handles realistic spin physics
- **Aggregate Roots**: `BettingTable` manages all bets and payouts, `RouletteWheel` controls spin mechanics
- **Value Objects**: Immutable `RouletteNumber`, `BetType`, and `PayoutRatio` objects
- **Repository Pattern**: Game history persistence and betting pattern analysis

#### 2. Physics-Based Wheel Simulation
- **Realistic Physics**: Ball trajectory with gravity, friction, and bounce physics using realistic deceleration curves
- **Visual Authenticity**: 37 numbers (European) or 38 numbers (American), proper spacing and colors
- **Spin Variations**: Variable speed, duration, and ball behavior for authentic randomness
- **Animation Timing**: 8-12 second spins with 2-3 bounces before settling, synchronized audio

#### 3. Comprehensive Betting System
- **Inside Bets**: Straight (35:1), Split (17:1), Street (11:1), Corner (8:1), Line (5:1)
- **Outside Bets**: Red/Black (1:1), Odd/Even (1:1), High/Low (1:1), Dozens (2:1), Columns (2:1)
- **Mobile Betting Interface**: Drag-and-drop chips, quick bet buttons, multi-touch support
- **Bet Validation**: Table limits, minimum bets, maximum total exposure per spin

#### 4. Advanced Features
- **Game Variants**: Toggle between American (double-zero) and European (single-zero) rules
- **Betting Strategies**: Quick bet presets for common strategies (Martingale, Fibonacci, d'Alembert)
- **Statistics Tracking**: Hot/cold numbers, color streaks, betting history analysis
- **Session Management**: Bankroll tracking, win/loss statistics, time played analytics

### Implementation Code

**services/casino/roulette/RouletteGameService.ts**:
```typescript
// Domain service following DDD principles
export class RouletteGameService {
  private readonly wheelPhysics: WheelPhysicsService
  private readonly bettingTable: BettingTableService
  private readonly payoutCalculator: PayoutCalculatorService
  private readonly historyService: RouletteHistoryService

  constructor(
    wheelPhysics: WheelPhysicsService,
    bettingTable: BettingTableService,
    payoutCalculator: PayoutCalculatorService,
    historyService: RouletteHistoryService
  ) {
    this.wheelPhysics = wheelPhysics
    this.bettingTable = bettingTable
    this.payoutCalculator = payoutCalculator
    this.historyService = historyService
  }

  // Core domain operation - process spin with all placed bets
  public async processSpin(gameState: RouletteGameState): Promise<RouletteSpinResult> {
    // Validate betting state before spin
    const betValidation = this.bettingTable.validateAllBets(gameState.placedBets)
    if (!betValidation.isValid) {
      throw new RouletteGameError('Invalid betting state', betValidation.errors)
    }

    // Calculate total bet amount for balance validation
    const totalBetAmount = gameState.placedBets.reduce((sum, bet) => sum + bet.amount, 0)
    if (totalBetAmount === 0) {
      throw new RouletteGameError('No bets placed')
    }

    // Execute wheel spin with physics simulation
    const spinResult = await this.wheelPhysics.simulateSpin(gameState.wheelType)
    
    // Determine winning and losing bets
    const betResults = this.payoutCalculator.calculatePayouts(
      gameState.placedBets, 
      spinResult.winningNumber
    )

    // Calculate total winnings and update game state
    const totalWinnings = betResults.reduce((sum, result) => 
      result.isWin ? sum + result.payout : sum, 0
    )

    // Update number history for statistical tracking
    this.historyService.addSpinResult({
      number: spinResult.winningNumber,
      timestamp: Date.now(),
      totalBetAmount,
      totalWinnings,
      betCount: gameState.placedBets.length
    })

    return {
      success: true,
      winningNumber: spinResult.winningNumber,
      spinDuration: spinResult.duration,
      betResults,
      totalWinnings,
      netResult: totalWinnings - totalBetAmount,
      nextGameState: {
        ...gameState,
        lastWinningNumber: spinResult.winningNumber,
        placedBets: [], // Clear bets for next round
        isSpinning: false
      }
    }
  }

  // Domain operation - validate and place bet
  public placeBet(
    gameState: RouletteGameState,
    betType: BetType,
    position: BetPosition,
    amount: number
  ): RouletteBetResult {
    // Validate bet placement rules
    const validation = this.bettingTable.validateBetPlacement({
      type: betType,
      position,
      amount,
      existingBets: gameState.placedBets,
      wheelType: gameState.wheelType
    })

    if (!validation.isValid) {
      return { success: false, error: validation.error }
    }

    // Create new bet entity
    const newBet: RouletteBet = {
      id: crypto.randomUUID(),
      type: betType,
      position,
      amount,
      payoutRatio: this.bettingTable.getPayoutRatio(betType),
      placedAt: Date.now()
    }

    // Add to game state
    const updatedBets = [...gameState.placedBets, newBet]
    const updatedState = {
      ...gameState,
      placedBets: updatedBets,
      totalBetAmount: updatedBets.reduce((sum, bet) => sum + bet.amount, 0)
    }

    return { success: true, bet: newBet, gameState: updatedState }
  }

  // Get available bet types for current wheel configuration
  public getAvailableBets(wheelType: RouletteWheelType): BetTypeInfo[] {
    return ROULETTE_BET_TYPES.filter(betType => 
      wheelType === 'european' ? betType.availableInEuropean : betType.availableInAmerican
    )
  }
}
```

**services/casino/roulette/WheelPhysicsService.ts**:
```typescript
// Physics simulation service for authentic wheel behavior
export class WheelPhysicsService {
  private readonly rngService: CasinoRNGService

  constructor(rngService: CasinoRNGService) {
    this.rngService = rngService
  }

  // Simulate realistic wheel spin with physics
  public async simulateSpin(wheelType: RouletteWheelType): Promise<WheelSpinResult> {
    const wheelLayout = wheelType === 'european' ? EUROPEAN_WHEEL : AMERICAN_WHEEL
    
    // Generate random but realistic spin parameters
    const spinDuration = 8000 + (this.rngService.randomFloat() * 4000) // 8-12 seconds
    const initialVelocity = 15 + (this.rngService.randomFloat() * 10) // RPM
    const ballBounces = 2 + Math.floor(this.rngService.randomFloat() * 3) // 2-4 bounces
    
    // Physics simulation with deceleration curves
    const deceleration = this.calculateDeceleration(spinDuration, initialVelocity)
    const finalPosition = this.simulateBallTrajectory(
      initialVelocity,
      deceleration,
      ballBounces,
      wheelLayout
    )

    // Determine winning number based on final ball position
    const winningNumber = this.getNumberAtPosition(finalPosition, wheelLayout)
    const winningColor = this.getNumberColor(winningNumber, wheelType)

    return {
      winningNumber,
      winningColor,
      duration: spinDuration,
      ballPath: this.generateBallPath(initialVelocity, deceleration, spinDuration),
      bouncePositions: this.calculateBouncePositions(ballBounces, finalPosition),
      finalPosition
    }
  }

  // Calculate realistic deceleration curve
  private calculateDeceleration(duration: number, initialVelocity: number): number {
    // Physics: v = v0 - at, where final velocity approaches 0
    return initialVelocity / (duration / 1000)
  }

  // Simulate ball trajectory with bounces and friction
  private simulateBallTrajectory(
    initialVelocity: number,
    deceleration: number,
    bounces: number,
    wheelLayout: RouletteNumber[]
  ): number {
    let currentVelocity = initialVelocity
    let position = this.rngService.randomFloat() * 360 // Starting angle in degrees
    let time = 0
    const timeStep = 0.1 // 100ms physics steps

    // Simulate physics over time
    while (currentVelocity > 0.5) { // Stop when velocity is very low
      currentVelocity = Math.max(0, currentVelocity - deceleration * timeStep)
      position += currentVelocity * timeStep * 6 // Convert RPM to degrees/second
      time += timeStep * 1000
      
      // Handle bounce physics at random intervals
      if (bounces > 0 && this.rngService.randomFloat() < 0.1) {
        currentVelocity *= 0.7 // Velocity reduction on bounce
        position += this.rngService.randomFloat() * 10 - 5 // Random position shift
        bounces--
      }
    }

    return position % 360 // Normalize to 0-360 degrees
  }

  // Map position angle to roulette number
  private getNumberAtPosition(angle: number, wheelLayout: RouletteNumber[]): number {
    const positionIndex = Math.floor((angle / 360) * wheelLayout.length)
    return wheelLayout[positionIndex % wheelLayout.length].number
  }

  // Generate smooth ball path for animation
  private generateBallPath(
    initialVelocity: number,
    deceleration: number,
    duration: number
  ): BallPathPoint[] {
    const path: BallPathPoint[] = []
    const steps = Math.floor(duration / 50) // 50ms intervals for smooth animation
    
    for (let i = 0; i <= steps; i++) {
      const time = (i / steps) * (duration / 1000)
      const velocity = Math.max(0, initialVelocity - deceleration * time)
      const angle = this.integrateVelocity(initialVelocity, deceleration, time)
      
      path.push({
        time: time * 1000,
        angle: angle % 360,
        velocity,
        radius: 180 - (velocity * 2) // Ball moves inward as it slows
      })
    }
    
    return path
  }
}
```

**hooks/casino/useRoulette.ts**:
```typescript
// Main application service hook following architecture patterns
export const useRoulette = (wheelType: RouletteWheelType = 'european'): RouletteGameHook => {
  const { balance, placeBet, addWinnings } = useCasinoBalance()
  const { playSound } = useCasinoAudio()
  const { vibrate } = useHapticFeedback()
  
  const gameServiceRef = useRef(new RouletteGameService(
    new WheelPhysicsService(new CasinoRNGService()),
    new BettingTableService(),
    new PayoutCalculatorService(),
    new RouletteHistoryService()
  ))

  const [gameState, setGameState] = useState<RouletteGameState>({
    wheelType,
    placedBets: [],
    totalBetAmount: 0,
    isSpinning: false,
    lastWinningNumber: null,
    numberHistory: [],
    sessionStats: { spins: 0, totalWagered: 0, totalWon: 0 }
  })

  const [wheelAnimation, setWheelAnimation] = useState<WheelAnimationState>({
    isSpinning: false,
    ballPath: [],
    currentAngle: 0,
    spinDuration: 0
  })

  // Place bet on roulette table
  const placeBetOnTable = useCallback((
    betType: BetType,
    position: BetPosition,
    amount: number
  ): boolean => {
    if (gameState.isSpinning) {
      toast.error('Cannot place bets while wheel is spinning')
      return false
    }

    if (!balance.canAfford(amount)) {
      toast.error('Insufficient balance for bet')
      return false
    }

    // Validate and place bet through domain service
    const result = gameServiceRef.current.placeBet(gameState, betType, position, amount)
    
    if (result.success) {
      setGameState(result.gameState)
      placeBet(amount)
      playSound('chipPlace')
      vibrate('spin')
      return true
    } else {
      toast.error(result.error)
      return false
    }
  }, [gameState, balance, placeBet, playSound, vibrate])

  // Execute wheel spin with all placed bets
  const spinWheel = useCallback(async (): Promise<boolean> => {
    if (gameState.placedBets.length === 0) {
      toast.error('Place at least one bet before spinning')
      return false
    }

    if (gameState.isSpinning) {
      return false
    }

    setGameState(prev => ({ ...prev, isSpinning: true }))
    setWheelAnimation(prev => ({ ...prev, isSpinning: true }))
    
    try {
      // Play spinning sounds
      playSound('wheelSpin')
      vibrate('spin')

      // Process spin through domain service
      const spinResult = await gameServiceRef.current.processSpin(gameState)
      
      if (spinResult.success) {
        // Animate wheel and ball movement
        setWheelAnimation({
          isSpinning: true,
          ballPath: spinResult.ballPath,
          currentAngle: 0,
          spinDuration: spinResult.spinDuration
        })

        // Wait for animation to complete
        await new Promise(resolve => setTimeout(resolve, spinResult.spinDuration))
        
        // Update game state with results
        setGameState(spinResult.nextGameState)
        setWheelAnimation(prev => ({ ...prev, isSpinning: false }))

        // Handle winnings
        if (spinResult.totalWinnings > 0) {
          addWinnings(spinResult.totalWinnings)
          playSound(spinResult.totalWinnings > gameState.totalBetAmount * 5 ? 'winBig' : 'winSmall')
          vibrate(spinResult.totalWinnings > gameState.totalBetAmount * 5 ? 'bigWin' : 'smallWin')
        } else {
          playSound('lose')
        }

        // Announce winning number
        setTimeout(() => {
          playSound('numberAnnounce')
        }, 500)

        return true
      }
    } catch (error) {
      toast.error('Spin failed: ' + error.message)
      setGameState(prev => ({ ...prev, isSpinning: false }))
      setWheelAnimation(prev => ({ ...prev, isSpinning: false }))
      return false
    }
  }, [gameState, playSound, vibrate, addWinnings])

  // Clear all placed bets
  const clearBets = useCallback(() => {
    if (gameState.isSpinning) {
      toast.error('Cannot clear bets while spinning')
      return false
    }

    // Refund all bet amounts
    const totalRefund = gameState.totalBetAmount
    if (totalRefund > 0) {
      addWinnings(totalRefund)
      playSound('chipCollect')
    }

    setGameState(prev => ({
      ...prev,
      placedBets: [],
      totalBetAmount: 0
    }))

    return true
  }, [gameState, addWinnings, playSound])

  // Repeat previous round's bets
  const repeatBets = useCallback(() => {
    if (gameState.numberHistory.length === 0) {
      toast.error('No previous bets to repeat')
      return false
    }

    const lastRound = gameState.numberHistory[gameState.numberHistory.length - 1]
    if (!lastRound.bets || lastRound.bets.length === 0) {
      toast.error('No previous bets found')
      return false
    }

    const totalBetAmount = lastRound.bets.reduce((sum, bet) => sum + bet.amount, 0)
    if (!balance.canAfford(totalBetAmount)) {
      toast.error('Insufficient balance to repeat bets')
      return false
    }

    // Place all previous bets
    let success = true
    for (const bet of lastRound.bets) {
      const placed = placeBetOnTable(bet.type, bet.position, bet.amount)
      if (!placed) {
        success = false
        break
      }
    }

    if (success) {
      toast.success('Previous bets repeated')
    }

    return success
  }, [gameState, balance, placeBetOnTable])

  return {
    gameState,
    wheelAnimation,
    // Actions
    placeBet: placeBetOnTable,
    spinWheel,
    clearBets,
    repeatBets,
    // Computed state
    canSpin: gameState.placedBets.length > 0 && !gameState.isSpinning,
    totalBetsPlaced: gameState.placedBets.length,
    potentialPayout: gameState.placedBets.reduce((sum, bet) => 
      sum + (bet.amount * bet.payoutRatio), 0
    ),
    // Statistics
    hotNumbers: getHotNumbers(gameState.numberHistory),
    coldNumbers: getColdNumbers(gameState.numberHistory),
    recentNumbers: gameState.numberHistory.slice(-10).map(h => h.number)
  }
}
```

## Phase 12: Craps Game (Priority 12 - Medium)

### Overview
Complete craps game implementation following domain-driven design principles with dice physics simulation, comprehensive betting options, and simplified mobile-friendly interface focusing on pass line and popular bets.

### Domain Models and Entities
Following DDD patterns with clear domain boundaries for the complex craps betting system:

#### Core Domain Entities
- **CrapsTable Entity**: Aggregate root managing game phase, point, and all active bets
- **DiceRoll Entity**: Two dice with values, roll history, and outcome determination
- **CrapsBet Entity**: Bet type, amount, point dependency, and payout calculation
- **GamePhase Entity**: Come out roll vs point phase with different betting rules
- **ShooterRotation Entity**: Player rotation and dice passing logic

#### Value Objects
- **DiceOutcome**: Combined dice value, individual die values, specific combinations (hard ways)
- **BetType**: Pass/don't pass, come/don't come, field bets, proposition bets
- **CrapsPoint**: Established point number (4,5,6,8,9,10) with true odds
- **PayoutOdds**: True odds vs house edge for different bet types
- **RollResult**: Win, lose, or establish point based on current game phase

### Files to Create

#### Domain Layer (Business Logic)
- `src/services/casino/craps/CrapsGameService.ts` - Core game rules and betting logic
- `src/services/casino/craps/DicePhysicsService.ts` - Dice rolling physics and animation
- `src/services/casino/craps/BettingTableService.ts` - Bet validation and payout calculation
- `src/services/casino/craps/GamePhaseService.ts` - Come out vs point phase management
- `src/services/casino/craps/PayoutCalculatorService.ts` - Complex payout rules for all bet types

#### Types and Value Objects
- `src/types/casino/craps.types.ts` - All craps domain types and betting options
- `src/utils/casino/craps/dice-combinations.utils.ts` - Dice outcome analysis and probabilities
- `src/utils/casino/craps/bet-validation.utils.ts` - Betting rules and restrictions
- `src/utils/casino/craps/payout-calculation.utils.ts` - True odds and house edge calculations
- `src/utils/casino/craps/game-phase.utils.ts` - Phase transition logic and rules

#### Constants and Configuration
- `src/constants/casino/craps/bet-types.constants.ts` - All craps bets with odds and payouts
- `src/constants/casino/craps/dice-combinations.constants.ts` - All possible dice outcomes
- `src/constants/casino/craps/table-limits.constants.ts` - Minimum and maximum bet limits
- `src/constants/casino/craps/true-odds.constants.ts` - Mathematical odds for all bets

#### Application Services (Hooks)
- `src/hooks/casino/useCraps.ts` - Main game state management hook
- `src/hooks/casino/useCrapsBetting.ts` - Betting interface and validation
- `src/hooks/casino/useDiceAnimation.ts` - Dice rolling animation control
- `src/hooks/casino/useCrapsHistory.ts` - Roll history and pattern tracking

#### Presentation Layer (Components)
- `src/pages/casino/CrapsPage.tsx` - Main craps page component
- `src/components/casino/craps/CrapsTable.tsx` - Complete craps table layout
- `src/components/casino/craps/DiceArea.tsx` - Dice display with physics animation
- `src/components/casino/craps/BettingLayout.tsx` - Simplified betting areas for mobile
- `src/components/casino/craps/PassLineBets.tsx` - Pass/don't pass betting interface
- `src/components/casino/craps/PointDisplay.tsx` - Current point and phase indicator
- `src/components/casino/craps/RollHistory.tsx` - Recent dice rolls and outcomes
- `src/components/casino/craps/PayoutDisplay.tsx` - Winning bet announcements

### Files to Modify
- `src/pages/index.ts` (add CrapsPage export)
- `src/App.tsx` (add craps routing)
- `src/types/casino/index.ts` (add craps types export)
- `src/stores/casinoStore.ts` (add craps game state)

### Integration Points
- `src/services/casino/CasinoRNGService.ts` - Dice rolling random generation
- `src/stores/casinoStore.ts` - Balance management and betting history
- `src/hooks/casino/useCasinoAudio.ts` - Dice rolling and winning sounds
- `src/components/casino/shared/TouchFeedback.tsx` - Betting area interactions

### Key Deliverables

#### 1. Domain-Driven Architecture
Following the architecture guide's DDD principles:
- **Domain Services**: `CrapsGameService` manages game flow, `GamePhaseService` handles come out/point phases
- **Aggregate Roots**: `CrapsTable` manages all bets and game state
- **Value Objects**: Immutable `DiceOutcome`, `BetType`, and `PayoutOdds` objects
- **Business Rules**: Proper phase transitions, bet resolution, and payout calculations

#### 2. Simplified Craps Rules
- **Core Bets Only**: Pass line, don't pass, field, and basic proposition bets
- **Two-Phase Game**: Come out roll (establish point) and point phase (resolve point)
- **Mobile-Friendly**: Reduced complexity focusing on most popular bets
- **Clear Instructions**: Visual guides for new players learning craps rules

#### 3. Physics-Based Dice Simulation
- **Realistic Dice Rolling**: 3D physics simulation with bounce, rotation, and settling
- **Visual Authenticity**: Proper dice appearance with readable numbers and red dots
- **Animation Timing**: 2-3 second rolls with realistic physics and multiple bounces
- **Random Generation**: Cryptographically secure dice outcomes with no bias

#### 4. Mobile-Optimized Interface
- **Touch Betting Areas**: Large betting zones optimized for finger taps
- **Simplified Layout**: Focus on pass line and popular bets, hide complex proposition bets
- **Visual Feedback**: Clear indication of active bets, winning areas, and point status
- **Portrait Orientation**: Vertical table layout designed for mobile screens

### Implementation Code

**services/casino/craps/CrapsGameService.ts**:
```typescript
// Domain service following DDD principles
export class CrapsGameService {
  private readonly dicePhysics: DicePhysicsService
  private readonly bettingTable: BettingTableService
  private readonly gamePhase: GamePhaseService
  private readonly payoutCalculator: PayoutCalculatorService

  constructor(
    dicePhysics: DicePhysicsService,
    bettingTable: BettingTableService,
    gamePhase: GamePhaseService,
    payoutCalculator: PayoutCalculatorService
  ) {
    this.dicePhysics = dicePhysics
    this.bettingTable = bettingTable
    this.gamePhase = gamePhase
    this.payoutCalculator = payoutCalculator
  }

  // Core domain operation - roll dice and resolve all bets
  public async rollDice(gameState: CrapsGameState): Promise<CrapsRollResult> {
    if (gameState.placedBets.length === 0) {
      throw new CrapsGameError('No bets placed')
    }

    // Execute dice roll with physics simulation
    const rollResult = await this.dicePhysics.rollDice()
    const totalValue = rollResult.die1 + rollResult.die2
    
    // Determine game outcome based on current phase
    const outcome = this.determineOutcome(gameState, totalValue, rollResult)
    
    // Process all bet resolutions
    const betResults = this.payoutCalculator.resolveBets(
      gameState.placedBets,
      outcome,
      gameState.currentPhase,
      gameState.point
    )

    // Calculate winnings and update phase
    const totalWinnings = betResults.reduce((sum, result) => 
      result.isWin ? sum + result.payout : sum, 0
    )

    // Update game phase based on roll outcome
    const nextPhase = this.gamePhase.updatePhase(
      gameState.currentPhase,
      totalValue,
      gameState.point
    )

    return {
      success: true,
      diceRoll: rollResult,
      totalValue,
      outcome,
      betResults,
      totalWinnings,
      nextGameState: {
        ...gameState,
        currentPhase: nextPhase.phase,
        point: nextPhase.point,
        rollHistory: [...gameState.rollHistory, { 
          roll: rollResult, 
          total: totalValue, 
          timestamp: Date.now(),
          outcome: outcome.type
        }],
        placedBets: betResults
          .filter(result => !result.isResolved) // Keep ongoing bets
          .map(result => result.originalBet)
      }
    }
  }

  // Determine roll outcome based on phase and dice value
  private determineOutcome(
    gameState: CrapsGameState,
    totalValue: number,
    diceRoll: DiceRoll
  ): CrapsOutcome {
    if (gameState.currentPhase === 'come-out') {
      // Come out roll logic
      if (totalValue === 7 || totalValue === 11) {
        return { type: 'natural-win', description: 'Natural winner!' }
      }
      if (totalValue === 2 || totalValue === 3 || totalValue === 12) {
        return { type: 'craps', description: 'Craps!' }
      }
      // Establish point
      return { 
        type: 'point-established', 
        description: `Point is ${totalValue}`,
        pointValue: totalValue
      }
    } else {
      // Point phase logic
      if (totalValue === gameState.point) {
        return { type: 'point-made', description: `${totalValue} winner!` }
      }
      if (totalValue === 7) {
        return { type: 'seven-out', description: 'Seven out!' }
      }
      return { type: 'no-decision', description: `Roll again` }
    }
  }

  // Place bet with validation
  public placeBet(
    gameState: CrapsGameState,
    betType: CrapsBetType,
    amount: number
  ): CrapsBetResult {
    // Validate bet is allowed in current phase
    const validation = this.bettingTable.validateBet(
      betType,
      amount,
      gameState.currentPhase,
      gameState.point
    )

    if (!validation.isValid) {
      return { success: false, error: validation.error }
    }

    // Create new bet entity
    const newBet: CrapsBet = {
      id: crypto.randomUUID(),
      type: betType,
      amount,
      phase: gameState.currentPhase,
      point: gameState.point,
      placedAt: Date.now(),
      odds: this.bettingTable.getBetOdds(betType)
    }

    const updatedBets = [...gameState.placedBets, newBet]
    const updatedState = {
      ...gameState,
      placedBets: updatedBets,
      totalBetAmount: updatedBets.reduce((sum, bet) => sum + bet.amount, 0)
    }

    return { success: true, bet: newBet, gameState: updatedState }
  }
}
```

**hooks/casino/useCraps.ts**:
```typescript
// Main application service hook following architecture patterns
export const useCraps = (): CrapsGameHook => {
  const { balance, placeBet, addWinnings } = useCasinoBalance()
  const { playSound } = useCasinoAudio()
  const { vibrate } = useHapticFeedback()
  
  const gameServiceRef = useRef(new CrapsGameService(
    new DicePhysicsService(),
    new BettingTableService(),
    new GamePhaseService(),
    new PayoutCalculatorService()
  ))

  const [gameState, setGameState] = useState<CrapsGameState>({
    currentPhase: 'come-out',
    point: null,
    placedBets: [],
    totalBetAmount: 0,
    isRolling: false,
    rollHistory: [],
    sessionStats: { rolls: 0, totalWagered: 0, totalWon: 0 }
  })

  const [diceAnimation, setDiceAnimation] = useState<DiceAnimationState>({
    isRolling: false,
    die1Value: 1,
    die2Value: 1,
    rollDuration: 0
  })

  // Place bet on craps table
  const placeBetOnTable = useCallback((
    betType: CrapsBetType,
    amount: number
  ): boolean => {
    if (gameState.isRolling) {
      toast.error('Cannot place bets while dice are rolling')
      return false
    }

    if (!balance.canAfford(amount)) {
      toast.error('Insufficient balance for bet')
      return false
    }

    // Place bet through domain service
    const result = gameServiceRef.current.placeBet(gameState, betType, amount)
    
    if (result.success) {
      setGameState(result.gameState)
      placeBet(amount)
      playSound('chipPlace')
      vibrate('spin')
      return true
    } else {
      toast.error(result.error)
      return false
    }
  }, [gameState, balance, placeBet, playSound, vibrate])

  // Roll dice and resolve bets
  const rollDice = useCallback(async (): Promise<boolean> => {
    if (gameState.placedBets.length === 0) {
      toast.error('Place at least one bet before rolling')
      return false
    }

    if (gameState.isRolling) {
      return false
    }

    setGameState(prev => ({ ...prev, isRolling: true }))
    setDiceAnimation(prev => ({ ...prev, isRolling: true }))
    
    try {
      // Play dice rolling sound
      playSound('diceRoll')
      vibrate('spin')

      // Process dice roll through domain service
      const rollResult = await gameServiceRef.current.rollDice(gameState)
      
      if (rollResult.success) {
        // Animate dice rolling
        const rollDuration = 2500 + (Math.random() * 1000) // 2.5-3.5 seconds
        setDiceAnimation({
          isRolling: true,
          die1Value: rollResult.diceRoll.die1,
          die2Value: rollResult.diceRoll.die2,
          rollDuration
        })

        // Wait for dice animation
        await new Promise(resolve => setTimeout(resolve, rollDuration))
        
        // Update game state with results
        setGameState(rollResult.nextGameState)
        setDiceAnimation(prev => ({ ...prev, isRolling: false }))

        // Handle audio feedback based on outcome
        switch (rollResult.outcome.type) {
          case 'natural-win':
          case 'point-made':
            playSound('winSmall')
            vibrate('smallWin')
            break
          case 'craps':
          case 'seven-out':
            playSound('lose')
            break
          case 'point-established':
            playSound('pointEstablished')
            break
          default:
            playSound('rollAgain')
        }

        // Process winnings
        if (rollResult.totalWinnings > 0) {
          addWinnings(rollResult.totalWinnings)
        }

        return true
      }
    } catch (error) {
      toast.error('Roll failed: ' + error.message)
      setGameState(prev => ({ ...prev, isRolling: false }))
      setDiceAnimation(prev => ({ ...prev, isRolling: false }))
      return false
    }
  }, [gameState, playSound, vibrate, addWinnings])

  return {
    gameState,
    diceAnimation,
    // Actions
    placeBet: placeBetOnTable,
    rollDice,
    // Computed state
    canRoll: gameState.placedBets.length > 0 && !gameState.isRolling,
    phase: gameState.currentPhase,
    point: gameState.point,
    totalBetsPlaced: gameState.placedBets.length,
    // Available bets based on current phase
    availableBets: getAvailableBets(gameState.currentPhase),
    // Statistics
    recentRolls: gameState.rollHistory.slice(-10)
  }
}
```

## Phase 13: PWA Features (Priority 13 - Low)

### Overview
Progressive Web App features for enhanced mobile experience including offline play and installation.

### Files to Create
- `public/sw.js` (service worker)
- `src/services/casino/PWAService.ts`
- `src/services/casino/CacheService.ts`
- `src/services/casino/OfflineGameService.ts`
- `src/hooks/casino/usePWAFeatures.ts`
- `src/hooks/casino/useOfflineGame.ts`
- `src/components/casino/shared/InstallPrompt.tsx`
- `src/components/casino/shared/OfflineIndicator.tsx`
- `src/utils/casino/cache.utils.ts`

### Files to Modify
- `public/manifest.json` (enhance PWA manifest)
- `src/main.tsx` (register service worker)
- `src/components/casino/shared/index.ts` (add PWA components)

### Integration Points
- Service Worker API
- Cache API
- IndexedDB for offline storage
- All casino games (offline functionality)

### Key Deliverables
1. **Service Worker**: Cache-First for game assets, Network-First for balance updates, 50MB cache limit
2. **Install Experience**: Install prompts after 3+ gaming sessions, fullscreen gaming with custom nav
3. **Offline Gaming**: Cached game assets, offline balance tracking with sync when online
4. **Device Features**: Screen Wake Lock for extended play, orientation lock for landscape games
5. **PWA Manifest**: `"display": "standalone"`, proper theming, 192x192 and 512x512 icons

## Implementation Guidelines

### Code Quality Standards
1. **TypeScript**: Strict mode with comprehensive type coverage
2. **Testing**: Minimum 80% code coverage for game logic
3. **Performance**: <16ms React render times, 60fps animations
4. **Accessibility**: WCAG 2.1 AA compliance
5. **Mobile**: Touch target minimum 44px, responsive design

### Architecture Principles
1. **Single Responsibility**: Each component/service has one clear purpose
2. **DRY**: Shared logic in utilities, hooks, and services
3. **Composition**: Favor composition over inheritance
4. **Immutability**: Immutable state updates throughout
5. **Error Boundaries**: Comprehensive error handling and recovery

### Development Workflow
1. **Phase Completion**: Each phase must pass all tests before next phase
2. **Code Reviews**: All casino game logic requires mathematical validation
3. **Device Testing**: Test on minimum 3 different mobile devices per phase
4. **Performance Validation**: Lighthouse CI scoring >90 for performance
5. **Accessibility Audit**: Screen reader testing for all new components