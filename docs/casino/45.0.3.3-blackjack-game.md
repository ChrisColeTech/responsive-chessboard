# Blackjack Game Implementation Plan

## Game Overview

Single-player Blackjack game featuring a player vs. dealer AI implementation optimized for mobile-first gameplay. The game leverages the existing casino infrastructure (audio, balance management, state management) to provide a seamless gaming experience.

### Game Features
- **Classic Rules**: Hit, Stand, Double Down with simplified single-deck gameplay
- **Dealer AI**: Realistic dealer behavior (hits under 17, stands on 17+) with thinking delays
- **Mobile-Optimized**: Touch-friendly interface with gesture support
- **Audio Integration**: Card dealing sounds, win/lose audio feedback
- **Balance Integration**: Uses shared casino balance system
- **Visual Design**: High-contrast cards optimized for mobile screens

## Technical Requirements

### Core Dependencies
- React 18+ with TypeScript
- React Spring for animations
- Zustand store integration (casinoStore)
- Web Audio API integration
- Touch/gesture event handling

### Browser Support
- Modern mobile browsers (iOS Safari 14+, Chrome Mobile 90+)
- Touch event support required
- Web Audio API support
- CSS transforms and animations

### Performance Targets
- < 100ms card dealing animations
- 60fps smooth transitions
- < 50KB total audio assets
- Responsive layout 320px - 768px

## Files to Create

### Core Game Components
- `src/pages/casino/BlackjackPage.tsx` - Main blackjack page wrapper
- `src/components/casino/blackjack/BlackjackGame.tsx` - Primary game container
- `src/components/casino/blackjack/Card.tsx` - Individual card component
- `src/components/casino/blackjack/Hand.tsx` - Player/dealer hand display
- `src/components/casino/blackjack/DealerArea.tsx` - Dealer section with AI status
- `src/components/casino/blackjack/PlayerArea.tsx` - Player section with controls
- `src/components/casino/blackjack/ActionButtons.tsx` - Hit/Stand/Double button controls

### Game Logic & Services
- `src/services/casino/BlackjackLogic.ts` - Core game rules and state management
- `src/services/casino/CardDeckService.ts` - 52-card deck management and shuffling
- `src/hooks/casino/useBlackjack.ts` - Main game state hook
- `src/utils/casino/card-game.utils.ts` - Card utility functions (value calculation, etc.)

### Type Definitions & Constants
- `src/types/casino/blackjack.types.ts` - All blackjack-related types
- `src/constants/casino/blackjack-rules.constants.ts` - Game rules and payouts

## Files to Modify

### Integration Updates
- `src/pages/index.ts` - Add BlackjackPage export
- `src/App.tsx` - Add blackjack routing (`/casino/blackjack`)
- `src/types/casino/index.ts` - Export blackjack types

## Integration Points with Main Infrastructure

### Casino Store Integration
**File**: `src/stores/casinoStore.ts` (from Phase 6)
- Balance management and bet placement
- Game session tracking
- Win/loss statistics

### Audio System Integration
**File**: `src/hooks/casino/useCasinoAudio.ts` (from Phase 4)
- Card dealing sounds (`cardDeal`, `cardFlip`)
- Win/lose audio feedback (`winSmall`, `winBig`, `lose`)
- Chip betting sounds (`chipBet`)

### Balance Management Integration
**File**: `src/hooks/casino/useCasinoBalance.ts` (from Phase 6)
- Bet validation and placement
- Payout processing
- Balance updates

## Detailed Implementation Steps

### Step 1: Core Types and Constants (2 hours)

Create comprehensive type definitions for all blackjack entities:

```typescript
// src/types/casino/blackjack.types.ts
export interface BlackjackCard {
  suit: 'hearts' | 'diamonds' | 'clubs' | 'spades'
  rank: 'A' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | '10' | 'J' | 'Q' | 'K'
  value: number // 1-11 for Ace, face cards = 10
  isVisible: boolean
}

export interface BlackjackHand {
  cards: BlackjackCard[]
  value: number
  isSoft: boolean // Contains ace counted as 11
  isBusted: boolean
  isBlackjack: boolean
}

export interface BlackjackGameState {
  playerHand: BlackjackHand
  dealerHand: BlackjackHand
  deck: BlackjackCard[]
  currentBet: number
  gamePhase: 'betting' | 'dealing' | 'player-turn' | 'dealer-turn' | 'game-over'
  canHit: boolean
  canStand: boolean
  canDouble: boolean
  gameResult: 'player-wins' | 'dealer-wins' | 'push' | 'blackjack' | null
}
```

Define game constants:
```typescript
// src/constants/casino/blackjack-rules.constants.ts
export const BLACKJACK_RULES = {
  BLACKJACK_VALUE: 21,
  DEALER_HITS_UNDER: 17,
  BLACKJACK_PAYOUT: 1.5, // 3:2 payout
  REGULAR_PAYOUT: 1.0,
  MIN_BET: 1,
  MAX_BET: 100,
  DECK_SHUFFLE_THRESHOLD: 0.75 // Shuffle at 75% deck penetration
} as const
```

### Step 2: Card System Implementation (3 hours)

Implement the 52-card deck system with proper shuffling:

```typescript
// src/services/casino/CardDeckService.ts
export class CardDeckService {
  createNewDeck(): BlackjackCard[] {
    const suits: BlackjackCard['suit'][] = ['hearts', 'diamonds', 'clubs', 'spades']
    const ranks: BlackjackCard['rank'][] = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']
    
    const deck: BlackjackCard[] = []
    
    suits.forEach(suit => {
      ranks.forEach(rank => {
        deck.push({
          suit,
          rank,
          value: this.getCardValue(rank),
          isVisible: false
        })
      })
    })
    
    return this.shuffleDeck(deck)
  }

  private getCardValue(rank: BlackjackCard['rank']): number {
    if (rank === 'A') return 11 // Ace high by default
    if (['J', 'Q', 'K'].includes(rank)) return 10
    return parseInt(rank)
  }

  shuffleDeck(deck: BlackjackCard[]): BlackjackCard[] {
    // Fisher-Yates shuffle using crypto-secure RNG
    const shuffled = [...deck]
    const crypto = window.crypto || (window as any).msCrypto
    
    for (let i = shuffled.length - 1; i > 0; i--) {
      const randomBytes = new Uint32Array(1)
      crypto.getRandomValues(randomBytes)
      const j = Math.floor((randomBytes[0] / 0x100000000) * (i + 1))
      ;[shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]]
    }
    
    return shuffled
  }
}
```

### Step 3: Game Logic Implementation (4 hours)

Core blackjack game rules and state management:

```typescript
// src/services/casino/BlackjackLogic.ts
export class BlackjackLogic {
  calculateHandValue(hand: BlackjackCard[]): { value: number; isSoft: boolean } {
    let value = 0
    let aces = 0
    
    // Count non-ace cards first
    hand.forEach(card => {
      if (card.rank === 'A') {
        aces++
      } else {
        value += card.value
      }
    })
    
    // Handle aces (11 or 1)
    let softAces = 0
    for (let i = 0; i < aces; i++) {
      if (value + 11 <= 21 && softAces === 0) {
        value += 11
        softAces++
      } else {
        value += 1
      }
    }
    
    return {
      value,
      isSoft: softAces > 0
    }
  }

  isBlackjack(hand: BlackjackCard[]): boolean {
    return hand.length === 2 && this.calculateHandValue(hand).value === 21
  }

  shouldDealerHit(dealerHand: BlackjackCard[]): boolean {
    const { value, isSoft } = this.calculateHandValue(dealerHand)
    
    // Dealer hits soft 17
    if (value < 17) return true
    if (value === 17 && isSoft) return true
    
    return false
  }

  determineWinner(
    playerHand: BlackjackCard[], 
    dealerHand: BlackjackCard[]
  ): 'player-wins' | 'dealer-wins' | 'push' | 'blackjack' {
    const playerValue = this.calculateHandValue(playerHand)
    const dealerValue = this.calculateHandValue(dealerHand)
    
    const playerBlackjack = this.isBlackjack(playerHand)
    const dealerBlackjack = this.isBlackjack(dealerHand)
    
    // Blackjack scenarios
    if (playerBlackjack && dealerBlackjack) return 'push'
    if (playerBlackjack && !dealerBlackjack) return 'blackjack'
    if (!playerBlackjack && dealerBlackjack) return 'dealer-wins'
    
    // Bust scenarios
    if (playerValue.value > 21) return 'dealer-wins'
    if (dealerValue.value > 21) return 'player-wins'
    
    // Value comparison
    if (playerValue.value > dealerValue.value) return 'player-wins'
    if (dealerValue.value > playerValue.value) return 'dealer-wins'
    
    return 'push'
  }
}
```

### Step 4: Main Game Hook Implementation (3 hours)

Central game state management with audio and balance integration:

```typescript
// src/hooks/casino/useBlackjack.ts
export const useBlackjack = () => {
  const [gameState, setGameState] = useState<BlackjackGameState>(initialGameState)
  const { balance, placeBet, addWinnings } = useCasinoBalance()
  const { playSound } = useCasinoAudio()
  
  const cardDeckService = useMemo(() => new CardDeckService(), [])
  const blackjackLogic = useMemo(() => new BlackjackLogic(), [])

  const startNewGame = useCallback(async (betAmount: number) => {
    if (!placeBet(betAmount)) return false
    
    playSound('chipBet')
    
    // Create new deck if needed
    const needsNewDeck = gameState.deck.length < (52 * BLACKJACK_RULES.DECK_SHUFFLE_THRESHOLD)
    const deck = needsNewDeck ? cardDeckService.createNewDeck() : [...gameState.deck]
    
    if (needsNewDeck) {
      playSound('shuffle')
    }
    
    // Deal initial cards
    const newDeck = [...deck]
    const playerCards = [newDeck.pop()!, newDeck.pop()!]
    const dealerCards = [newDeck.pop()!, { ...newDeck.pop()!, isVisible: false }]
    
    // Make cards visible
    playerCards.forEach(card => card.isVisible = true)
    dealerCards[0].isVisible = true // Only first dealer card visible
    
    setGameState(prev => ({
      ...prev,
      deck: newDeck,
      playerHand: {
        cards: playerCards,
        ...blackjackLogic.calculateHandValue(playerCards),
        isBusted: false,
        isBlackjack: blackjackLogic.isBlackjack(playerCards)
      },
      dealerHand: {
        cards: dealerCards,
        ...blackjackLogic.calculateHandValue([dealerCards[0]]), // Only visible card
        isBusted: false,
        isBlackjack: false // Unknown until revealed
      },
      currentBet: betAmount,
      gamePhase: 'dealing',
      canHit: true,
      canStand: true,
      canDouble: balance >= betAmount,
      gameResult: null
    }))
    
    // Deal cards with animation delays
    setTimeout(() => playSound('cardDeal'), 100)
    setTimeout(() => playSound('cardDeal'), 300)
    setTimeout(() => playSound('cardDeal'), 500)
    setTimeout(() => playSound('cardDeal'), 700)
    
    // Check for immediate blackjack
    setTimeout(() => {
      if (blackjackLogic.isBlackjack(playerCards)) {
        handlePlayerBlackjack()
      } else {
        setGameState(prev => ({ ...prev, gamePhase: 'player-turn' }))
      }
    }, 1000)
    
    return true
  }, [gameState.deck, balance, placeBet, playSound, blackjackLogic, cardDeckService])

  const hit = useCallback(() => {
    if (gameState.gamePhase !== 'player-turn') return
    
    const newCard = { ...gameState.deck[gameState.deck.length - 1], isVisible: true }
    const newPlayerCards = [...gameState.playerHand.cards, newCard]
    const newDeck = gameState.deck.slice(0, -1)
    
    playSound('cardDeal')
    
    const handValue = blackjackLogic.calculateHandValue(newPlayerCards)
    const isBusted = handValue.value > 21
    
    setGameState(prev => ({
      ...prev,
      deck: newDeck,
      playerHand: {
        cards: newPlayerCards,
        ...handValue,
        isBusted,
        isBlackjack: false
      },
      canDouble: false // Can only double on first two cards
    }))
    
    if (isBusted) {
      setTimeout(() => {
        playSound('lose')
        setGameState(prev => ({
          ...prev,
          gamePhase: 'game-over',
          gameResult: 'dealer-wins',
          canHit: false,
          canStand: false
        }))
      }, 500)
    }
  }, [gameState, playSound, blackjackLogic])

  const stand = useCallback(() => {
    if (gameState.gamePhase !== 'player-turn') return
    
    setGameState(prev => ({
      ...prev,
      gamePhase: 'dealer-turn',
      canHit: false,
      canStand: false,
      canDouble: false
    }))
    
    // Reveal dealer's hidden card and play dealer turn
    setTimeout(() => {
      revealDealerCardAndPlay()
    }, 500)
  }, [gameState.gamePhase])

  const doubleDown = useCallback(() => {
    if (!gameState.canDouble || !placeBet(gameState.currentBet)) return
    
    playSound('chipBet')
    
    // Hit once then automatically stand
    const newCard = { ...gameState.deck[gameState.deck.length - 1], isVisible: true }
    const newPlayerCards = [...gameState.playerHand.cards, newCard]
    const handValue = blackjackLogic.calculateHandValue(newPlayerCards)
    
    playSound('cardDeal')
    
    setGameState(prev => ({
      ...prev,
      deck: prev.deck.slice(0, -1),
      playerHand: {
        cards: newPlayerCards,
        ...handValue,
        isBusted: handValue.value > 21,
        isBlackjack: false
      },
      currentBet: prev.currentBet * 2,
      canHit: false,
      canStand: false,
      canDouble: false
    }))
    
    if (handValue.value > 21) {
      setTimeout(() => {
        playSound('lose')
        setGameState(prev => ({
          ...prev,
          gamePhase: 'game-over',
          gameResult: 'dealer-wins'
        }))
      }, 500)
    } else {
      setTimeout(() => {
        setGameState(prev => ({ ...prev, gamePhase: 'dealer-turn' }))
        revealDealerCardAndPlay()
      }, 1000)
    }
  }, [gameState, placeBet, playSound, blackjackLogic])

  return {
    gameState,
    startNewGame,
    hit,
    stand,
    doubleDown,
    canStartNewGame: gameState.gamePhase === 'betting' || gameState.gamePhase === 'game-over'
  }
}
```

### Step 5: Card Component Implementation (2 hours)

Visual card representation optimized for mobile:

```typescript
// src/components/casino/blackjack/Card.tsx
export const Card: React.FC<CardProps> = ({ 
  card, 
  isAnimating = false,
  animationDelay = 0,
  onClick 
}) => {
  const cardSpring = useSpring({
    from: { 
      opacity: 0, 
      transform: 'translateY(-100px) rotateY(180deg)',
      scale: 0.8
    },
    to: { 
      opacity: card.isVisible ? 1 : 0.8,
      transform: card.isVisible 
        ? 'translateY(0px) rotateY(0deg)' 
        : 'translateY(0px) rotateY(180deg)',
      scale: 1
    },
    delay: animationDelay,
    config: { tension: 200, friction: 20 }
  })

  const getSuitColor = (suit: BlackjackCard['suit']) => {
    return suit === 'hearts' || suit === 'diamonds' ? '#dc2626' : '#1f2937'
  }

  const getSuitSymbol = (suit: BlackjackCard['suit']) => {
    const symbols = { hearts: '♥', diamonds: '♦', clubs: '♣', spades: '♠' }
    return symbols[suit]
  }

  return (
    <animated.div
      style={cardSpring}
      className={`
        blackjack-card
        ${!card.isVisible ? 'card-back' : ''}
        ${onClick ? 'cursor-pointer' : ''}
      `}
      onClick={onClick}
    >
      {card.isVisible ? (
        <div className="card-front" style={{ color: getSuitColor(card.suit) }}>
          <div className="card-corner top-left">
            <div className="card-rank">{card.rank}</div>
            <div className="card-suit">{getSuitSymbol(card.suit)}</div>
          </div>
          <div className="card-center">
            <div className="card-suit-large">{getSuitSymbol(card.suit)}</div>
          </div>
          <div className="card-corner bottom-right">
            <div className="card-rank">{card.rank}</div>
            <div className="card-suit">{getSuitSymbol(card.suit)}</div>
          </div>
        </div>
      ) : (
        <div className="card-back-pattern">
          <div className="card-logo">♠♥♣♦</div>
        </div>
      )}
    </animated.div>
  )
}

// CSS (in component file or stylesheet)
const cardStyles = `
.blackjack-card {
  width: 80px;
  height: 120px;
  border-radius: 8px;
  background: white;
  border: 2px solid #374151;
  position: relative;
  box-shadow: 0 2px 8px rgba(0,0,0,0.15);
  user-select: none;
  min-width: 80px; /* Mobile minimum touch target */
}

.card-front {
  width: 100%;
  height: 100%;
  padding: 6px;
  position: relative;
}

.card-corner {
  position: absolute;
  font-size: 14px;
  font-weight: bold;
  line-height: 1;
}

.card-corner.top-left {
  top: 6px;
  left: 6px;
}

.card-corner.bottom-right {
  bottom: 6px;
  right: 6px;
  transform: rotate(180deg);
}

.card-center {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

.card-suit-large {
  font-size: 32px;
  opacity: 0.3;
}

.card-back-pattern {
  width: 100%;
  height: 100%;
  background: linear-gradient(45deg, #1e40af, #3b82f6);
  border-radius: 6px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.card-logo {
  color: white;
  font-size: 20px;
  opacity: 0.8;
}

@media (max-width: 480px) {
  .blackjack-card {
    width: 70px;
    height: 105px;
  }
  
  .card-corner {
    font-size: 12px;
  }
  
  .card-suit-large {
    font-size: 28px;
  }
}
`
```

### Step 6: Dealer AI Implementation (2 hours)

Realistic dealer behavior with thinking delays:

```typescript
// src/services/casino/BlackjackLogic.ts (additional methods)
export class BlackjackLogic {
  async playDealerTurn(
    dealerHand: BlackjackCard[], 
    deck: BlackjackCard[],
    onCardDealt: (card: BlackjackCard) => void,
    onThinking: () => void
  ): Promise<{ finalHand: BlackjackCard[], remainingDeck: BlackjackCard[] }> {
    let currentHand = [...dealerHand]
    let currentDeck = [...deck]
    
    // Reveal hidden card first
    currentHand[1].isVisible = true
    await this.delay(800)
    
    while (this.shouldDealerHit(currentHand)) {
      onThinking()
      
      // Dealer thinking delay (1-2 seconds)
      const thinkingTime = 1000 + Math.random() * 1000
      await this.delay(thinkingTime)
      
      // Deal card
      const newCard = { ...currentDeck.pop()!, isVisible: true }
      currentHand.push(newCard)
      currentDeck = [...currentDeck]
      
      onCardDealt(newCard)
      
      // Brief pause after dealing
      await this.delay(600)
    }
    
    return { finalHand: currentHand, remainingDeck: currentDeck }
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms))
  }
}
```

### Step 7: Mobile-First UI Components (4 hours)

#### Action Buttons Component
```typescript
// src/components/casino/blackjack/ActionButtons.tsx
export const ActionButtons: React.FC<ActionButtonsProps> = ({
  canHit,
  canStand,
  canDouble,
  onHit,
  onStand,
  onDouble,
  currentBet,
  balance
}) => {
  return (
    <div className="action-buttons">
      <button
        className={`action-button hit-button ${!canHit ? 'disabled' : ''}`}
        disabled={!canHit}
        onClick={onHit}
      >
        <span className="button-icon">👆</span>
        <span className="button-text">HIT</span>
      </button>
      
      <button
        className={`action-button stand-button ${!canStand ? 'disabled' : ''}`}
        disabled={!canStand}
        onClick={onStand}
      >
        <span className="button-icon">✋</span>
        <span className="button-text">STAND</span>
      </button>
      
      {canDouble && (
        <button
          className={`action-button double-button ${balance < currentBet ? 'disabled' : ''}`}
          disabled={balance < currentBet}
          onClick={onDouble}
        >
          <span className="button-icon">💰</span>
          <span className="button-text">DOUBLE</span>
        </button>
      )}
    </div>
  )
}
```

#### Hand Component
```typescript
// src/components/casino/blackjack/Hand.tsx
export const Hand: React.FC<HandProps> = ({ 
  hand, 
  isDealer = false,
  showValue = true,
  isThinking = false 
}) => {
  const handSpring = useSpring({
    from: { opacity: 0, transform: 'translateY(20px)' },
    to: { opacity: 1, transform: 'translateY(0px)' },
    config: { tension: 200, friction: 25 }
  })

  return (
    <animated.div style={handSpring} className="blackjack-hand">
      <div className="hand-cards">
        {hand.cards.map((card, index) => (
          <Card
            key={`${card.suit}-${card.rank}-${index}`}
            card={card}
            animationDelay={index * 200}
            isAnimating={true}
          />
        ))}
      </div>
      
      {showValue && hand.cards.some(card => card.isVisible) && (
        <div className="hand-value">
          {isDealer && isThinking ? (
            <div className="thinking-indicator">
              <span>🤔</span>
              <span>Thinking...</span>
            </div>
          ) : (
            <>
              <span className="value-number">{hand.value}</span>
              {hand.isSoft && <span className="soft-indicator">SOFT</span>}
              {hand.isBlackjack && <span className="blackjack-indicator">BLACKJACK!</span>}
              {hand.isBusted && <span className="busted-indicator">BUST!</span>}
            </>
          )}
        </div>
      )}
    </animated.div>
  )
}
```

### Step 8: Main Game Page Implementation (2 hours)

```typescript
// src/pages/casino/BlackjackPage.tsx
export const BlackjackPage: React.FC = () => {
  const navigate = useNavigate()
  const { 
    gameState, 
    startNewGame, 
    hit, 
    stand, 
    doubleDown, 
    canStartNewGame 
  } = useBlackjack()
  const { balance } = useCasinoBalance()
  
  const [betAmount, setBetAmount] = useState(5)
  const [isThinking, setIsThinking] = useState(false)

  const handleStartGame = useCallback(async () => {
    const success = await startNewGame(betAmount)
    if (!success) {
      toast.error('Insufficient balance for bet')
    }
  }, [startNewGame, betAmount])

  const getResultMessage = () => {
    switch (gameState.gameResult) {
      case 'blackjack':
        return { text: 'BLACKJACK!', payout: gameState.currentBet * 2.5 }
      case 'player-wins':
        return { text: 'YOU WIN!', payout: gameState.currentBet * 2 }
      case 'push':
        return { text: 'PUSH', payout: gameState.currentBet }
      case 'dealer-wins':
        return { text: 'DEALER WINS', payout: 0 }
      default:
        return null
    }
  }

  return (
    <div className="blackjack-page">
      <CasinoHeader 
        title="Blackjack"
        balance={balance}
        onBack={() => navigate('/casino')}
      />
      
      <div className="game-area">
        {/* Dealer Area */}
        <div className="dealer-section">
          <h3>Dealer</h3>
          <Hand 
            hand={gameState.dealerHand}
            isDealer={true}
            showValue={gameState.gamePhase !== 'player-turn'}
            isThinking={isThinking}
          />
        </div>

        {/* Game Status */}
        <div className="game-status">
          {gameState.gamePhase === 'betting' && (
            <div className="betting-phase">
              <h4>Place Your Bet</h4>
              <BetControls
                currentBet={betAmount}
                balance={balance}
                minBet={BLACKJACK_RULES.MIN_BET}
                maxBet={BLACKJACK_RULES.MAX_BET}
                onBetChange={setBetAmount}
              />
              <button 
                className="deal-button"
                onClick={handleStartGame}
                disabled={betAmount > balance}
              >
                DEAL CARDS
              </button>
            </div>
          )}
          
          {gameState.gameResult && (
            <div className="game-result">
              <h4>{getResultMessage()?.text}</h4>
              {getResultMessage()?.payout! > 0 && (
                <p>You won {getResultMessage()?.payout} coins!</p>
              )}
              <button 
                className="new-game-button"
                onClick={() => window.location.reload()}
              >
                NEW GAME
              </button>
            </div>
          )}
        </div>

        {/* Player Area */}
        <div className="player-section">
          <h3>Your Hand</h3>
          <Hand 
            hand={gameState.playerHand}
            showValue={true}
          />
          
          {gameState.gamePhase === 'player-turn' && (
            <ActionButtons
              canHit={gameState.canHit}
              canStand={gameState.canStand}
              canDouble={gameState.canDouble}
              onHit={hit}
              onStand={stand}
              onDouble={doubleDown}
              currentBet={gameState.currentBet}
              balance={balance}
            />
          )}
        </div>
      </div>
    </div>
  )
}
```

## Card System Details

### 52-Card Deck Implementation
- **Standard Deck**: 4 suits × 13 ranks = 52 cards
- **Shuffle Algorithm**: Fisher-Yates using `crypto.getRandomValues()` for fair play
- **Deck Penetration**: Reshuffles at 75% (39 cards used)
- **Card Values**: Ace=1/11, Face cards=10, Numbers=face value

### Card Display Optimization
- **Minimum Size**: 80×120px for touch accessibility
- **Mobile Scaling**: Responsive down to 70×105px on small screens
- **High Contrast**: Clear rank and suit visibility
- **Animation**: Smooth dealing with React Spring

## Dealer AI Logic

### Dealer Rules Implementation
- **Hit Condition**: Hand value < 17
- **Soft 17 Rule**: Dealer hits on soft 17 (A+6)
- **Stand Condition**: Hard 17+ or soft 18+
- **Thinking Delays**: 1-2 second randomized delays for realism

### AI Behavior Patterns
```typescript
// Dealer decision logic
if (handValue < 17) {
  // Always hit
  return 'hit'
} else if (handValue === 17 && isSoftHand) {
  // Hit soft 17
  return 'hit'  
} else {
  // Stand on 17+
  return 'stand'
}
```

## Mobile-First Design

### Touch Interface Requirements
- **Button Size**: Minimum 60×60px for action buttons
- **Card Size**: 80×120px minimum for card selection
- **Spacing**: 16px minimum between touch targets
- **Swipe Gestures**: Optional swipe up=hit, swipe down=stand

### Portrait Layout Optimization
```css
.blackjack-page {
  display: flex;
  flex-direction: column;
  height: 100vh;
  padding: 16px;
}

.dealer-section {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
}

.player-section {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-end;
}

.action-buttons {
  display: flex;
  gap: 12px;
  margin-top: 16px;
}

.action-button {
  min-width: 80px;
  min-height: 60px;
  border-radius: 12px;
  font-weight: bold;
  font-size: 16px;
}
```

## Audio Integration

### Sound Effects Library
- **Card Dealing**: `cardDeal.mp3` (300ms, <10KB)
- **Card Flip**: `cardFlip.mp3` (200ms, <8KB)  
- **Chip Bet**: `chipBet.mp3` (400ms, <12KB)
- **Shuffle**: `shuffle.mp3` (1500ms, <25KB)
- **Win Small**: `winSmall.mp3` (800ms, <15KB)
- **Win Big**: `winBig.mp3` (1200ms, <20KB)
- **Lose**: `lose.mp3` (600ms, <12KB)

### Audio Implementation
```typescript
// Audio event triggers
const audioEvents = {
  onStartGame: () => playSound('chipBet'),
  onCardDeal: () => playSound('cardDeal'),
  onCardFlip: () => playSound('cardFlip'),
  onShuffle: () => playSound('shuffle'),
  onPlayerWin: (amount: number) => {
    playSound(amount > betAmount * 5 ? 'winBig' : 'winSmall')
  },
  onPlayerLose: () => playSound('lose')
}
```

## Testing Requirements

### Unit Tests
- `BlackjackLogic.test.ts` - Game rules and calculations
- `CardDeckService.test.ts` - Deck creation and shuffling
- `useBlackjack.test.ts` - Game state management

### Integration Tests  
- Full game flow testing
- Audio integration testing
- Balance management testing
- Mobile touch interaction testing

### Test Cases
```typescript
describe('BlackjackLogic', () => {
  describe('calculateHandValue', () => {
    it('should calculate basic hand values correctly', () => {
      expect(calculateHandValue([{rank: '7'}, {rank: '5'}])).toEqual({ value: 12, isSoft: false })
    })
    
    it('should handle ace as 11 when possible', () => {
      expect(calculateHandValue([{rank: 'A'}, {rank: '9'}])).toEqual({ value: 20, isSoft: true })
    })
    
    it('should convert ace to 1 when needed', () => {
      expect(calculateHandValue([{rank: 'A'}, {rank: '7'}, {rank: '8'}])).toEqual({ value: 16, isSoft: false })
    })
  })
  
  describe('isBlackjack', () => {
    it('should identify blackjack correctly', () => {
      expect(isBlackjack([{rank: 'A'}, {rank: 'K'}])).toBe(true)
      expect(isBlackjack([{rank: 'A'}, {rank: '10'}])).toBe(true)
      expect(isBlackjack([{rank: '7'}, {rank: '7'}, {rank: '7'}])).toBe(false)
    })
  })
})
```

### Performance Testing
- **Load Testing**: 1000+ consecutive games without memory leaks
- **Animation Performance**: 60fps during card dealing
- **Audio Performance**: No audio dropouts or overlapping
- **Battery Testing**: <5% battery drain per 30 minutes of play

## Implementation Timeline

| Phase | Task | Duration | Deliverable |
|-------|------|----------|-------------|
| 1 | Types & Constants | 2 hours | Complete type system |
| 2 | Card System | 3 hours | Deck service + shuffling |
| 3 | Game Logic | 4 hours | Core blackjack rules |
| 4 | Main Hook | 3 hours | State management |
| 5 | Card Components | 2 hours | Visual card display |
| 6 | Dealer AI | 2 hours | Realistic dealer behavior |
| 7 | UI Components | 4 hours | Mobile-first interface |
| 8 | Main Page | 2 hours | Complete game integration |
| 9 | Testing | 3 hours | Unit + integration tests |
| 10 | Polish & Bugs | 2 hours | Final refinements |

**Total Estimated Time**: 27 hours

## Success Criteria

### Functional Requirements
- ✅ Complete blackjack gameplay (hit/stand/double)
- ✅ Accurate game rules implementation
- ✅ Dealer AI with realistic behavior
- ✅ Mobile-optimized touch interface
- ✅ Audio feedback integration
- ✅ Balance management integration

### Performance Requirements
- ✅ <100ms response time for user actions
- ✅ 60fps smooth animations
- ✅ <200KB total JavaScript bundle size
- ✅ Works offline after initial load

### User Experience Requirements
- ✅ Intuitive mobile-first interface
- ✅ Clear visual feedback for all game states
- ✅ Accessible button sizes (60×60px minimum)
- ✅ Error handling with user-friendly messages
- ✅ Consistent casino theme integration

This implementation plan provides a complete roadmap for building a production-ready Blackjack game that integrates seamlessly with the existing casino infrastructure while delivering an exceptional mobile gaming experience.